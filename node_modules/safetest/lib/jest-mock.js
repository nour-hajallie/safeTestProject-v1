"use strict";
// Copied from https://github.com/jestjs/jest/blob/main/packages/jest-mock/src/index.ts
Object.defineProperty(exports, "__esModule", { value: true });
exports.replaceProperty = exports.mocked = exports.spyOn = exports.fn = exports.ModuleMocker = void 0;
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
const isPromise = (candidate) => {
    return (candidate != null &&
        (typeof candidate === 'object' || typeof candidate === 'function') &&
        typeof candidate.then === 'function');
};
const MOCK_CONSTRUCTOR_NAME = 'mockConstructor';
const FUNCTION_NAME_RESERVED_PATTERN = /[\s!-/:-@[-`{-~]/;
const FUNCTION_NAME_RESERVED_REPLACE = new RegExp(FUNCTION_NAME_RESERVED_PATTERN.source, 'g');
const RESERVED_KEYWORDS = new Set([
    'arguments',
    'await',
    'break',
    'case',
    'catch',
    'class',
    'const',
    'continue',
    'debugger',
    'default',
    'delete',
    'do',
    'else',
    'enum',
    'eval',
    'export',
    'extends',
    'false',
    'finally',
    'for',
    'function',
    'if',
    'implements',
    'import',
    'in',
    'instanceof',
    'interface',
    'let',
    'new',
    'null',
    'package',
    'private',
    'protected',
    'public',
    'return',
    'static',
    'super',
    'switch',
    'this',
    'throw',
    'true',
    'try',
    'typeof',
    'var',
    'void',
    'while',
    'with',
    'yield',
]);
function matchArity(fn, length) {
    let mockConstructor;
    switch (length) {
        case 1:
            mockConstructor = function (_a) {
                return fn.apply(this, arguments);
            };
            break;
        case 2:
            mockConstructor = function (_a, _b) {
                return fn.apply(this, arguments);
            };
            break;
        case 3:
            mockConstructor = function (_a, _b, _c) {
                return fn.apply(this, arguments);
            };
            break;
        case 4:
            mockConstructor = function (_a, _b, _c, _d) {
                return fn.apply(this, arguments);
            };
            break;
        case 5:
            mockConstructor = function (_a, _b, _c, _d, _e) {
                return fn.apply(this, arguments);
            };
            break;
        case 6:
            mockConstructor = function (_a, _b, _c, _d, _e, _f) {
                return fn.apply(this, arguments);
            };
            break;
        case 7:
            mockConstructor = function (_a, _b, _c, _d, _e, _f, _g) {
                return fn.apply(this, arguments);
            };
            break;
        case 8:
            mockConstructor = function (_a, _b, _c, _d, _e, _f, _g, _h) {
                return fn.apply(this, arguments);
            };
            break;
        case 9:
            mockConstructor = function (_a, _b, _c, _d, _e, _f, _g, _h, _i) {
                return fn.apply(this, arguments);
            };
            break;
        default:
            mockConstructor = function () {
                return fn.apply(this, arguments);
            };
            break;
    }
    return mockConstructor;
}
function getObjectType(value) {
    return Object.prototype.toString.apply(value).slice(8, -1);
}
function getType(ref) {
    const typeName = getObjectType(ref);
    if (typeName === 'Function' ||
        typeName === 'AsyncFunction' ||
        typeName === 'GeneratorFunction' ||
        typeName === 'AsyncGeneratorFunction') {
        return 'function';
    }
    else if (Array.isArray(ref)) {
        return 'array';
    }
    else if (typeName === 'Object' || typeName === 'Module') {
        return 'object';
    }
    else if (typeName === 'Number' ||
        typeName === 'String' ||
        typeName === 'Boolean' ||
        typeName === 'Symbol') {
        return 'constant';
    }
    else if (typeName === 'Map' ||
        typeName === 'WeakMap' ||
        typeName === 'Set') {
        return 'collection';
    }
    else if (typeName === 'RegExp') {
        return 'regexp';
    }
    else if (ref === undefined) {
        return 'undefined';
    }
    else if (ref === null) {
        return 'null';
    }
    else {
        return null;
    }
}
function isReadonlyProp(object, prop) {
    if (prop === 'arguments' ||
        prop === 'caller' ||
        prop === 'callee' ||
        prop === 'name' ||
        prop === 'length') {
        const typeName = getObjectType(object);
        return (typeName === 'Function' ||
            typeName === 'AsyncFunction' ||
            typeName === 'GeneratorFunction' ||
            typeName === 'AsyncGeneratorFunction');
    }
    if (prop === 'source' ||
        prop === 'global' ||
        prop === 'ignoreCase' ||
        prop === 'multiline') {
        return getObjectType(object) === 'RegExp';
    }
    return false;
}
class ModuleMocker {
    /**
     * @see README.md
     * @param global Global object of the test environment, used to create
     * mocks
     */
    constructor(global) {
        this._environmentGlobal = global;
        this._mockState = new WeakMap();
        this._mockConfigRegistry = new WeakMap();
        this._spyState = new Set();
        this._invocationCallCounter = 1;
    }
    _getSlots(object) {
        if (!object) {
            return [];
        }
        const slots = new Set();
        const EnvObjectProto = this._environmentGlobal.Object.prototype;
        const EnvFunctionProto = this._environmentGlobal.Function.prototype;
        const EnvRegExpProto = this._environmentGlobal.RegExp.prototype;
        // Also check the builtins in the current context as they leak through
        // core node modules.
        const ObjectProto = Object.prototype;
        const FunctionProto = Function.prototype;
        const RegExpProto = RegExp.prototype;
        // Properties of Object.prototype, Function.prototype and RegExp.prototype
        // are never reported as slots
        while (object != null &&
            object !== EnvObjectProto &&
            object !== EnvFunctionProto &&
            object !== EnvRegExpProto &&
            object !== ObjectProto &&
            object !== FunctionProto &&
            object !== RegExpProto) {
            const ownNames = Object.getOwnPropertyNames(object);
            for (let i = 0; i < ownNames.length; i++) {
                const prop = ownNames[i];
                if (!isReadonlyProp(object, prop)) {
                    const propDesc = Object.getOwnPropertyDescriptor(object, prop);
                    if ((propDesc !== undefined && !propDesc.get) ||
                        object['__esModule']) {
                        slots.add(prop);
                    }
                }
            }
            object = Object.getPrototypeOf(object);
        }
        return Array.from(slots);
    }
    _ensureMockConfig(f) {
        let config = this._mockConfigRegistry.get(f);
        if (!config) {
            config = this._defaultMockConfig();
            this._mockConfigRegistry.set(f, config);
        }
        return config;
    }
    _ensureMockState(f) {
        let state = this._mockState.get(f);
        if (!state) {
            state = this._defaultMockState();
            this._mockState.set(f, state);
        }
        if (state.calls.length > 0) {
            state.lastCall = state.calls[state.calls.length - 1];
        }
        return state;
    }
    _defaultMockConfig() {
        return {
            mockImpl: undefined,
            mockName: 'jest.fn()',
            specificMockImpls: [],
        };
    }
    _defaultMockState() {
        return {
            calls: [],
            contexts: [],
            instances: [],
            invocationCallOrder: [],
            results: [],
        };
    }
    _makeComponent(metadata, restore) {
        if (metadata.type === 'object') {
            return new this._environmentGlobal.Object();
        }
        else if (metadata.type === 'array') {
            return new this._environmentGlobal.Array();
        }
        else if (metadata.type === 'regexp') {
            return new this._environmentGlobal.RegExp('');
        }
        else if (metadata.type === 'constant' ||
            metadata.type === 'collection' ||
            metadata.type === 'null' ||
            metadata.type === 'undefined') {
            return metadata.value;
        }
        else if (metadata.type === 'function') {
            const prototype = (metadata.members &&
                metadata.members['prototype'] &&
                metadata.members['prototype'].members) ||
                {};
            const prototypeSlots = this._getSlots(prototype);
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            const mocker = this;
            const mockConstructor = matchArity(function (...args) {
                const mockState = mocker._ensureMockState(f);
                const mockConfig = mocker._ensureMockConfig(f);
                mockState.instances.push(this);
                mockState.contexts.push(this);
                mockState.calls.push(args);
                // Create and record an "incomplete" mock result immediately upon
                // calling rather than waiting for the mock to return. This avoids
                // issues caused by recursion where results can be recorded in the
                // wrong order.
                const mockResult = {
                    type: 'incomplete',
                    value: undefined,
                };
                mockState.results.push(mockResult);
                mockState.invocationCallOrder.push(mocker._invocationCallCounter++);
                // Will be set to the return value of the mock if an error is not thrown
                let finalReturnValue;
                // Will be set to the error that is thrown by the mock (if it throws)
                let thrownError;
                // Will be set to true if the mock throws an error. The presence of a
                // value in `thrownError` is not a 100% reliable indicator because a
                // function could throw a value of undefined.
                let callDidThrowError = false;
                try {
                    // The bulk of the implementation is wrapped in an immediately
                    // executed arrow function so the return value of the mock function
                    // can be easily captured and recorded, despite the many separate
                    // return points within the logic.
                    finalReturnValue = (() => {
                        if (this instanceof f) {
                            // This is probably being called as a constructor
                            prototypeSlots.forEach((slot) => {
                                // Copy prototype methods to the instance to make
                                // it easier to interact with mock instance call and
                                // return values
                                if (prototype[slot]?.type === 'function') {
                                    // @ts-expect-error no index signature
                                    const protoImpl = this[slot];
                                    // @ts-expect-error no index signature
                                    this[slot] = mocker.generateFromMetadata(prototype[slot]);
                                    // @ts-expect-error no index signature
                                    this[slot]._protoImpl = protoImpl;
                                }
                            });
                            // Run the mock constructor implementation
                            const mockImpl = mockConfig.specificMockImpls.length
                                ? mockConfig.specificMockImpls.shift()
                                : mockConfig.mockImpl;
                            return mockImpl && mockImpl.apply(this, arguments);
                        }
                        // If mockImplementationOnce()/mockImplementation() is last set,
                        // implementation use the mock
                        let specificMockImpl = mockConfig.specificMockImpls.shift();
                        if (specificMockImpl === undefined) {
                            specificMockImpl = mockConfig.mockImpl;
                        }
                        if (specificMockImpl) {
                            return specificMockImpl.apply(this, arguments);
                        }
                        // Otherwise use prototype implementation
                        if (f._protoImpl) {
                            return f._protoImpl.apply(this, arguments);
                        }
                        return undefined;
                    })();
                }
                catch (error) {
                    // Store the thrown error so we can record it, then re-throw it.
                    thrownError = error;
                    callDidThrowError = true;
                    throw error;
                }
                finally {
                    // Record the result of the function.
                    // NOTE: Intentionally NOT pushing/indexing into the array of mock
                    //       results here to avoid corrupting results data if mockClear()
                    //       is called during the execution of the mock.
                    // @ts-expect-error reassigning 'incomplete'
                    mockResult.type = callDidThrowError ? 'throw' : 'return';
                    mockResult.value = callDidThrowError ? thrownError : finalReturnValue;
                }
                return finalReturnValue;
            }, metadata.length || 0);
            const f = this._createMockFunction(metadata, mockConstructor);
            f._isMockFunction = true;
            f.getMockImplementation = () => this._ensureMockConfig(f).mockImpl;
            if (typeof restore === 'function') {
                this._spyState.add(restore);
            }
            this._mockState.set(f, this._defaultMockState());
            this._mockConfigRegistry.set(f, this._defaultMockConfig());
            Object.defineProperty(f, 'mock', {
                configurable: false,
                enumerable: true,
                get: () => this._ensureMockState(f),
                set: (val) => this._mockState.set(f, val),
            });
            f.mockClear = () => {
                this._mockState.delete(f);
                return f;
            };
            f.mockReset = () => {
                f.mockClear();
                this._mockConfigRegistry.delete(f);
                return f;
            };
            f.mockRestore = () => {
                f.mockReset();
                return restore ? restore() : undefined;
            };
            f.mockReturnValueOnce = (value) => 
            // next function call will return this value or default return value
            f.mockImplementationOnce(() => value);
            f.mockResolvedValueOnce = (value) => f.mockImplementationOnce(() => this._environmentGlobal.Promise.resolve(value));
            f.mockRejectedValueOnce = (value) => f.mockImplementationOnce(() => this._environmentGlobal.Promise.reject(value));
            f.mockReturnValue = (value) => 
            // next function call will return specified return value or this one
            f.mockImplementation(() => value);
            f.mockResolvedValue = (value) => f.mockImplementation(() => this._environmentGlobal.Promise.resolve(value));
            f.mockRejectedValue = (value) => f.mockImplementation(() => this._environmentGlobal.Promise.reject(value));
            f.mockImplementationOnce = (fn) => {
                // next function call will use this mock implementation return value
                // or default mock implementation return value
                const mockConfig = this._ensureMockConfig(f);
                mockConfig.specificMockImpls.push(fn);
                return f;
            };
            f.withImplementation = withImplementation.bind(this);
            function withImplementation(fn, callback) {
                // Remember previous mock implementation, then set new one
                const mockConfig = this._ensureMockConfig(f);
                const previousImplementation = mockConfig.mockImpl;
                const previousSpecificImplementations = mockConfig.specificMockImpls;
                mockConfig.mockImpl = fn;
                mockConfig.specificMockImpls = [];
                const returnedValue = callback();
                if (isPromise(returnedValue)) {
                    return returnedValue.then(() => {
                        mockConfig.mockImpl = previousImplementation;
                        mockConfig.specificMockImpls = previousSpecificImplementations;
                    });
                }
                else {
                    mockConfig.mockImpl = previousImplementation;
                    mockConfig.specificMockImpls = previousSpecificImplementations;
                }
            }
            f.mockImplementation = (fn) => {
                // next function call will use mock implementation return value
                const mockConfig = this._ensureMockConfig(f);
                mockConfig.mockImpl = fn;
                return f;
            };
            f.mockReturnThis = () => f.mockImplementation(function () {
                return this;
            });
            f.mockName = (name) => {
                if (name) {
                    const mockConfig = this._ensureMockConfig(f);
                    mockConfig.mockName = name;
                }
                return f;
            };
            f.getMockName = () => {
                const mockConfig = this._ensureMockConfig(f);
                return mockConfig.mockName || 'jest.fn()';
            };
            if (metadata.mockImpl) {
                f.mockImplementation(metadata.mockImpl);
            }
            return f;
        }
        else {
            const unknownType = metadata.type || 'undefined type';
            throw new Error(`Unrecognized type ${unknownType}`);
        }
    }
    _createMockFunction(metadata, mockConstructor) {
        let name = metadata.name;
        if (!name) {
            return mockConstructor;
        }
        // Preserve `name` property of mocked function.
        const boundFunctionPrefix = 'bound ';
        let bindCall = '';
        // if-do-while for perf reasons. The common case is for the if to fail.
        if (name.startsWith(boundFunctionPrefix)) {
            do {
                name = name.substring(boundFunctionPrefix.length);
                // Call bind() just to alter the function name.
                bindCall = '.bind(null)';
            } while (name && name.startsWith(boundFunctionPrefix));
        }
        // Special case functions named `mockConstructor` to guard for infinite loops
        if (name === MOCK_CONSTRUCTOR_NAME) {
            return mockConstructor;
        }
        if (
        // It's a syntax error to define functions with a reserved keyword as name
        RESERVED_KEYWORDS.has(name) ||
            // It's also a syntax error to define functions with a name that starts with a number
            /^\d/.test(name)) {
            name = `$${name}`;
        }
        // It's also a syntax error to define a function with a reserved character
        // as part of it's name.
        if (FUNCTION_NAME_RESERVED_PATTERN.test(name)) {
            name = name.replace(FUNCTION_NAME_RESERVED_REPLACE, '$');
        }
        const body = `return function ${name}() {` +
            `  return ${MOCK_CONSTRUCTOR_NAME}.apply(this,arguments);` +
            `}${bindCall}`;
        const createConstructor = new this._environmentGlobal.Function(MOCK_CONSTRUCTOR_NAME, body);
        return createConstructor(mockConstructor);
    }
    _generateMock(metadata, callbacks, refs) {
        // metadata not compatible but it's the same type, maybe problem with
        // overloading of _makeComponent and not _generateMock?
        // @ts-expect-error - unsure why TSC complains here?
        const mock = this._makeComponent(metadata);
        if (metadata.refID != null) {
            refs[metadata.refID] = mock;
        }
        this._getSlots(metadata.members).forEach((slot) => {
            const slotMetadata = (metadata.members && metadata.members[slot]) || {};
            if (slotMetadata.ref != null) {
                callbacks.push((function (ref) {
                    return () => (mock[slot] = refs[ref]);
                })(slotMetadata.ref));
            }
            else {
                mock[slot] = this._generateMock(slotMetadata, callbacks, refs);
            }
        });
        if (metadata.type !== 'undefined' &&
            metadata.type !== 'null' &&
            mock['prototype'] &&
            typeof mock['prototype'] === 'object') {
            mock['prototype'].constructor = mock;
        }
        return mock;
    }
    /**
     * Check whether the given property of an object has been already replaced.
     */
    _findReplacedProperty(object, propertyKey) {
        for (const spyState of this._spyState) {
            if ('object' in spyState &&
                'property' in spyState &&
                spyState.object === object &&
                spyState.property === propertyKey) {
                return spyState;
            }
        }
        return;
    }
    /**
     * @see README.md
     * @param metadata Metadata for the mock in the schema returned by the
     * getMetadata method of this module.
     */
    generateFromMetadata(metadata) {
        const callbacks = [];
        const refs = {};
        const mock = this._generateMock(metadata, callbacks, refs);
        callbacks.forEach((setter) => setter());
        return mock;
    }
    /**
     * @see README.md
     * @param component The component for which to retrieve metadata.
     */
    getMetadata(component, _refs) {
        const refs = _refs || new Map();
        const ref = refs.get(component);
        if (ref != null) {
            return { ref };
        }
        const type = getType(component);
        if (!type) {
            return null;
        }
        const metadata = { type };
        if (type === 'constant' ||
            type === 'collection' ||
            type === 'undefined' ||
            type === 'null') {
            metadata.value = component;
            return metadata;
        }
        else if (type === 'function') {
            // @ts-expect-error component is a function so it has a name, but not
            // necessarily a string: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name#function_names_in_classes
            const componentName = component.name;
            if (typeof componentName === 'string') {
                metadata.name = componentName;
            }
            if (this.isMockFunction(component)) {
                metadata.mockImpl = component.getMockImplementation();
            }
        }
        metadata.refID = refs.size;
        refs.set(component, metadata.refID);
        let members = null;
        // Leave arrays alone
        if (type !== 'array') {
            // @ts-expect-error component is object
            this._getSlots(component).forEach((slot) => {
                if (type === 'function' &&
                    this.isMockFunction(component) &&
                    slot.match(/^mock/)) {
                    return;
                }
                // @ts-expect-error no index signature
                const slotMetadata = this.getMetadata(component[slot], refs);
                if (slotMetadata) {
                    if (!members) {
                        members = {};
                    }
                    members[slot] = slotMetadata;
                }
            });
        }
        if (members) {
            metadata.members = members;
        }
        return metadata;
    }
    isMockFunction(fn) {
        return fn != null && fn._isMockFunction === true;
    }
    fn(implementation) {
        const length = implementation ? implementation.length : 0;
        const fn = this._makeComponent({
            length,
            type: 'function',
        });
        if (implementation) {
            fn.mockImplementation(implementation);
        }
        return fn;
    }
    spyOn(object, methodKey, accessType) {
        if (object == null ||
            (typeof object !== 'object' && typeof object !== 'function')) {
            throw new Error(`Cannot use spyOn on a primitive value; ${this._typeOf(object)} given`);
        }
        if (methodKey == null) {
            throw new Error('No property name supplied');
        }
        if (accessType) {
            return this._spyOnProperty(object, methodKey, accessType);
        }
        const original = object[methodKey];
        if (!original) {
            throw new Error(`Property \`${String(methodKey)}\` does not exist in the provided object`);
        }
        if (!this.isMockFunction(original)) {
            if (typeof original !== 'function') {
                throw new Error(`Cannot spy on the \`${String(methodKey)}\` property because it is not a function; ${this._typeOf(original)} given instead.${typeof original !== 'object'
                    ? ` If you are trying to mock a property, use \`jest.replaceProperty(object, '${String(methodKey)}', value)\` instead.`
                    : ''}`);
            }
            const isMethodOwner = Object.prototype.hasOwnProperty.call(object, methodKey);
            let descriptor = Object.getOwnPropertyDescriptor(object, methodKey);
            let proto = Object.getPrototypeOf(object);
            while (!descriptor && proto !== null) {
                descriptor = Object.getOwnPropertyDescriptor(proto, methodKey);
                proto = Object.getPrototypeOf(proto);
            }
            let mock;
            if (descriptor && descriptor.get) {
                const originalGet = descriptor.get;
                mock = this._makeComponent({ type: 'function' }, () => {
                    descriptor.get = originalGet;
                    Object.defineProperty(object, methodKey, descriptor);
                });
                descriptor.get = () => mock;
                Object.defineProperty(object, methodKey, descriptor);
            }
            else {
                mock = this._makeComponent({ type: 'function' }, () => {
                    if (isMethodOwner) {
                        object[methodKey] = original;
                    }
                    else {
                        delete object[methodKey];
                    }
                });
                // @ts-expect-error overriding original method with a Mock
                object[methodKey] = mock;
            }
            mock.mockImplementation(function () {
                return original.apply(this, arguments);
            });
        }
        return object[methodKey];
    }
    _spyOnProperty(object, propertyKey, accessType) {
        let descriptor = Object.getOwnPropertyDescriptor(object, propertyKey);
        let proto = Object.getPrototypeOf(object);
        while (!descriptor && proto !== null) {
            descriptor = Object.getOwnPropertyDescriptor(proto, propertyKey);
            proto = Object.getPrototypeOf(proto);
        }
        if (!descriptor) {
            throw new Error(`Property \`${String(propertyKey)}\` does not exist in the provided object`);
        }
        if (!descriptor.configurable) {
            throw new Error(`Property \`${String(propertyKey)}\` is not declared configurable`);
        }
        if (!descriptor[accessType]) {
            throw new Error(`Property \`${String(propertyKey)}\` does not have access type ${accessType}`);
        }
        const original = descriptor[accessType];
        if (!this.isMockFunction(original)) {
            if (typeof original !== 'function') {
                throw new Error(`Cannot spy on the ${String(propertyKey)} property because it is not a function; ${this._typeOf(original)} given instead.${typeof original !== 'object'
                    ? ` If you are trying to mock a property, use \`jest.replaceProperty(object, '${String(propertyKey)}', value)\` instead.`
                    : ''}`);
            }
            descriptor[accessType] = this._makeComponent({ type: 'function' }, () => {
                // @ts-expect-error: mock is assignable
                descriptor[accessType] = original;
                Object.defineProperty(object, propertyKey, descriptor);
            });
            descriptor[accessType].mockImplementation(function () {
                // @ts-expect-error - wrong context
                return original.apply(this, arguments);
            });
        }
        Object.defineProperty(object, propertyKey, descriptor);
        return descriptor[accessType];
    }
    replaceProperty(object, propertyKey, value) {
        if (object == null ||
            (typeof object !== 'object' && typeof object !== 'function')) {
            throw new Error(`Cannot use replaceProperty on a primitive value; ${this._typeOf(object)} given`);
        }
        if (propertyKey == null) {
            throw new Error('No property name supplied');
        }
        let descriptor = Object.getOwnPropertyDescriptor(object, propertyKey);
        let proto = Object.getPrototypeOf(object);
        while (!descriptor && proto !== null) {
            descriptor = Object.getOwnPropertyDescriptor(proto, propertyKey);
            proto = Object.getPrototypeOf(proto);
        }
        if (!descriptor) {
            throw new Error(`Property \`${String(propertyKey)}\` does not exist in the provided object`);
        }
        if (!descriptor.configurable) {
            throw new Error(`Property \`${String(propertyKey)}\` is not declared configurable`);
        }
        if (descriptor.get !== undefined) {
            throw new Error(`Cannot replace the \`${String(propertyKey)}\` property because it has a getter. Use \`jest.spyOn(object, '${String(propertyKey)}', 'get').mockReturnValue(value)\` instead.`);
        }
        if (descriptor.set !== undefined) {
            throw new Error(`Cannot replace the \`${String(propertyKey)}\` property because it has a setter. Use \`jest.spyOn(object, '${String(propertyKey)}', 'set').mockReturnValue(value)\` instead.`);
        }
        if (typeof descriptor.value === 'function') {
            throw new Error(`Cannot replace the \`${String(propertyKey)}\` property because it is a function. Use \`jest.spyOn(object, '${String(propertyKey)}')\` instead.`);
        }
        const existingRestore = this._findReplacedProperty(object, propertyKey);
        if (existingRestore) {
            return existingRestore.replaced.replaceValue(value);
        }
        const isPropertyOwner = Object.prototype.hasOwnProperty.call(object, propertyKey);
        const originalValue = descriptor.value;
        const restore = () => {
            if (isPropertyOwner) {
                object[propertyKey] = originalValue;
            }
            else {
                delete object[propertyKey];
            }
        };
        const replaced = {
            replaceValue: (value) => {
                object[propertyKey] = value;
                return replaced;
            },
            restore: () => {
                restore();
                this._spyState.delete(restore);
            },
        };
        restore.object = object;
        restore.property = propertyKey;
        restore.replaced = replaced;
        this._spyState.add(restore);
        return replaced.replaceValue(value);
    }
    clearAllMocks() {
        this._mockState = new WeakMap();
    }
    resetAllMocks() {
        this._mockConfigRegistry = new WeakMap();
        this._mockState = new WeakMap();
    }
    restoreAllMocks() {
        this._spyState.forEach((restore) => restore());
        this._spyState = new Set();
    }
    _typeOf(value) {
        return value == null ? `${value}` : typeof value;
    }
    mocked(source, _options) {
        return source;
    }
}
exports.ModuleMocker = ModuleMocker;
const JestMock = new ModuleMocker(globalThis);
exports.fn = JestMock.fn.bind(JestMock);
exports.spyOn = JestMock.spyOn.bind(JestMock);
exports.mocked = JestMock.mocked.bind(JestMock);
exports.replaceProperty = JestMock.replaceProperty.bind(JestMock);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiamVzdC1tb2NrLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2plc3QtbW9jay50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsdUZBQXVGOzs7QUFFdkY7Ozs7O0dBS0c7QUFFSCxNQUFNLFNBQVMsR0FBRyxDQUNoQixTQUFrQixFQUNXLEVBQUU7SUFDL0IsT0FBTyxDQUNMLFNBQVMsSUFBSSxJQUFJO1FBQ2pCLENBQUMsT0FBTyxTQUFTLEtBQUssUUFBUSxJQUFJLE9BQU8sU0FBUyxLQUFLLFVBQVUsQ0FBQztRQUNsRSxPQUFRLFNBQWlCLENBQUMsSUFBSSxLQUFLLFVBQVUsQ0FDOUMsQ0FBQztBQUNKLENBQUMsQ0FBQztBQXlQRixNQUFNLHFCQUFxQixHQUFHLGlCQUFpQixDQUFDO0FBRWhELE1BQU0sOEJBQThCLEdBQUcsa0JBQWtCLENBQUM7QUFDMUQsTUFBTSw4QkFBOEIsR0FBRyxJQUFJLE1BQU0sQ0FDL0MsOEJBQThCLENBQUMsTUFBTSxFQUNyQyxHQUFHLENBQ0osQ0FBQztBQUVGLE1BQU0saUJBQWlCLEdBQUcsSUFBSSxHQUFHLENBQUM7SUFDaEMsV0FBVztJQUNYLE9BQU87SUFDUCxPQUFPO0lBQ1AsTUFBTTtJQUNOLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLFVBQVU7SUFDVixVQUFVO0lBQ1YsU0FBUztJQUNULFFBQVE7SUFDUixJQUFJO0lBQ0osTUFBTTtJQUNOLE1BQU07SUFDTixNQUFNO0lBQ04sUUFBUTtJQUNSLFNBQVM7SUFDVCxPQUFPO0lBQ1AsU0FBUztJQUNULEtBQUs7SUFDTCxVQUFVO0lBQ1YsSUFBSTtJQUNKLFlBQVk7SUFDWixRQUFRO0lBQ1IsSUFBSTtJQUNKLFlBQVk7SUFDWixXQUFXO0lBQ1gsS0FBSztJQUNMLEtBQUs7SUFDTCxNQUFNO0lBQ04sU0FBUztJQUNULFNBQVM7SUFDVCxXQUFXO0lBQ1gsUUFBUTtJQUNSLFFBQVE7SUFDUixRQUFRO0lBQ1IsT0FBTztJQUNQLFFBQVE7SUFDUixNQUFNO0lBQ04sT0FBTztJQUNQLE1BQU07SUFDTixLQUFLO0lBQ0wsUUFBUTtJQUNSLEtBQUs7SUFDTCxNQUFNO0lBQ04sT0FBTztJQUNQLE1BQU07SUFDTixPQUFPO0NBQ1IsQ0FBQyxDQUFDO0FBRUgsU0FBUyxVQUFVLENBQUMsRUFBWSxFQUFFLE1BQWM7SUFDOUMsSUFBSSxlQUFlLENBQUM7SUFFcEIsUUFBUSxNQUFNLEVBQUU7UUFDZCxLQUFLLENBQUM7WUFDSixlQUFlLEdBQUcsVUFBeUIsRUFBVztnQkFDcEQsT0FBTyxFQUFFLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxTQUFTLENBQUMsQ0FBQztZQUNuQyxDQUFDLENBQUM7WUFDRixNQUFNO1FBQ1IsS0FBSyxDQUFDO1lBQ0osZUFBZSxHQUFHLFVBQXlCLEVBQVcsRUFBRSxFQUFXO2dCQUNqRSxPQUFPLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDO1lBQ25DLENBQUMsQ0FBQztZQUNGLE1BQU07UUFDUixLQUFLLENBQUM7WUFDSixlQUFlLEdBQUcsVUFFaEIsRUFBVyxFQUNYLEVBQVcsRUFDWCxFQUFXO2dCQUVYLE9BQU8sRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7WUFDbkMsQ0FBQyxDQUFDO1lBQ0YsTUFBTTtRQUNSLEtBQUssQ0FBQztZQUNKLGVBQWUsR0FBRyxVQUVoQixFQUFXLEVBQ1gsRUFBVyxFQUNYLEVBQVcsRUFDWCxFQUFXO2dCQUVYLE9BQU8sRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7WUFDbkMsQ0FBQyxDQUFDO1lBQ0YsTUFBTTtRQUNSLEtBQUssQ0FBQztZQUNKLGVBQWUsR0FBRyxVQUVoQixFQUFXLEVBQ1gsRUFBVyxFQUNYLEVBQVcsRUFDWCxFQUFXLEVBQ1gsRUFBVztnQkFFWCxPQUFPLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDO1lBQ25DLENBQUMsQ0FBQztZQUNGLE1BQU07UUFDUixLQUFLLENBQUM7WUFDSixlQUFlLEdBQUcsVUFFaEIsRUFBVyxFQUNYLEVBQVcsRUFDWCxFQUFXLEVBQ1gsRUFBVyxFQUNYLEVBQVcsRUFDWCxFQUFXO2dCQUVYLE9BQU8sRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7WUFDbkMsQ0FBQyxDQUFDO1lBQ0YsTUFBTTtRQUNSLEtBQUssQ0FBQztZQUNKLGVBQWUsR0FBRyxVQUVoQixFQUFXLEVBQ1gsRUFBVyxFQUNYLEVBQVcsRUFDWCxFQUFXLEVBQ1gsRUFBVyxFQUNYLEVBQVcsRUFDWCxFQUFXO2dCQUVYLE9BQU8sRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7WUFDbkMsQ0FBQyxDQUFDO1lBQ0YsTUFBTTtRQUNSLEtBQUssQ0FBQztZQUNKLGVBQWUsR0FBRyxVQUVoQixFQUFXLEVBQ1gsRUFBVyxFQUNYLEVBQVcsRUFDWCxFQUFXLEVBQ1gsRUFBVyxFQUNYLEVBQVcsRUFDWCxFQUFXLEVBQ1gsRUFBVztnQkFFWCxPQUFPLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDO1lBQ25DLENBQUMsQ0FBQztZQUNGLE1BQU07UUFDUixLQUFLLENBQUM7WUFDSixlQUFlLEdBQUcsVUFFaEIsRUFBVyxFQUNYLEVBQVcsRUFDWCxFQUFXLEVBQ1gsRUFBVyxFQUNYLEVBQVcsRUFDWCxFQUFXLEVBQ1gsRUFBVyxFQUNYLEVBQVcsRUFDWCxFQUFXO2dCQUVYLE9BQU8sRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7WUFDbkMsQ0FBQyxDQUFDO1lBQ0YsTUFBTTtRQUNSO1lBQ0UsZUFBZSxHQUFHO2dCQUNoQixPQUFPLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDO1lBQ25DLENBQUMsQ0FBQztZQUNGLE1BQU07S0FDVDtJQUVELE9BQU8sZUFBZSxDQUFDO0FBQ3pCLENBQUM7QUFFRCxTQUFTLGFBQWEsQ0FBQyxLQUFjO0lBQ25DLE9BQU8sTUFBTSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUM3RCxDQUFDO0FBRUQsU0FBUyxPQUFPLENBQUMsR0FBYTtJQUM1QixNQUFNLFFBQVEsR0FBRyxhQUFhLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDcEMsSUFDRSxRQUFRLEtBQUssVUFBVTtRQUN2QixRQUFRLEtBQUssZUFBZTtRQUM1QixRQUFRLEtBQUssbUJBQW1CO1FBQ2hDLFFBQVEsS0FBSyx3QkFBd0IsRUFDckM7UUFDQSxPQUFPLFVBQVUsQ0FBQztLQUNuQjtTQUFNLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFBRTtRQUM3QixPQUFPLE9BQU8sQ0FBQztLQUNoQjtTQUFNLElBQUksUUFBUSxLQUFLLFFBQVEsSUFBSSxRQUFRLEtBQUssUUFBUSxFQUFFO1FBQ3pELE9BQU8sUUFBUSxDQUFDO0tBQ2pCO1NBQU0sSUFDTCxRQUFRLEtBQUssUUFBUTtRQUNyQixRQUFRLEtBQUssUUFBUTtRQUNyQixRQUFRLEtBQUssU0FBUztRQUN0QixRQUFRLEtBQUssUUFBUSxFQUNyQjtRQUNBLE9BQU8sVUFBVSxDQUFDO0tBQ25CO1NBQU0sSUFDTCxRQUFRLEtBQUssS0FBSztRQUNsQixRQUFRLEtBQUssU0FBUztRQUN0QixRQUFRLEtBQUssS0FBSyxFQUNsQjtRQUNBLE9BQU8sWUFBWSxDQUFDO0tBQ3JCO1NBQU0sSUFBSSxRQUFRLEtBQUssUUFBUSxFQUFFO1FBQ2hDLE9BQU8sUUFBUSxDQUFDO0tBQ2pCO1NBQU0sSUFBSSxHQUFHLEtBQUssU0FBUyxFQUFFO1FBQzVCLE9BQU8sV0FBVyxDQUFDO0tBQ3BCO1NBQU0sSUFBSSxHQUFHLEtBQUssSUFBSSxFQUFFO1FBQ3ZCLE9BQU8sTUFBTSxDQUFDO0tBQ2Y7U0FBTTtRQUNMLE9BQU8sSUFBSSxDQUFDO0tBQ2I7QUFDSCxDQUFDO0FBRUQsU0FBUyxjQUFjLENBQUMsTUFBZSxFQUFFLElBQVk7SUFDbkQsSUFDRSxJQUFJLEtBQUssV0FBVztRQUNwQixJQUFJLEtBQUssUUFBUTtRQUNqQixJQUFJLEtBQUssUUFBUTtRQUNqQixJQUFJLEtBQUssTUFBTTtRQUNmLElBQUksS0FBSyxRQUFRLEVBQ2pCO1FBQ0EsTUFBTSxRQUFRLEdBQUcsYUFBYSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ3ZDLE9BQU8sQ0FDTCxRQUFRLEtBQUssVUFBVTtZQUN2QixRQUFRLEtBQUssZUFBZTtZQUM1QixRQUFRLEtBQUssbUJBQW1CO1lBQ2hDLFFBQVEsS0FBSyx3QkFBd0IsQ0FDdEMsQ0FBQztLQUNIO0lBRUQsSUFDRSxJQUFJLEtBQUssUUFBUTtRQUNqQixJQUFJLEtBQUssUUFBUTtRQUNqQixJQUFJLEtBQUssWUFBWTtRQUNyQixJQUFJLEtBQUssV0FBVyxFQUNwQjtRQUNBLE9BQU8sYUFBYSxDQUFDLE1BQU0sQ0FBQyxLQUFLLFFBQVEsQ0FBQztLQUMzQztJQUVELE9BQU8sS0FBSyxDQUFDO0FBQ2YsQ0FBQztBQUVELE1BQWEsWUFBWTtJQU92Qjs7OztPQUlHO0lBQ0gsWUFBWSxNQUF5QjtRQUNuQyxJQUFJLENBQUMsa0JBQWtCLEdBQUcsTUFBTSxDQUFDO1FBQ2pDLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxPQUFPLEVBQUUsQ0FBQztRQUNoQyxJQUFJLENBQUMsbUJBQW1CLEdBQUcsSUFBSSxPQUFPLEVBQUUsQ0FBQztRQUN6QyxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksR0FBRyxFQUFFLENBQUM7UUFDM0IsSUFBSSxDQUFDLHNCQUFzQixHQUFHLENBQUMsQ0FBQztJQUNsQyxDQUFDO0lBRU8sU0FBUyxDQUFDLE1BQTRCO1FBQzVDLElBQUksQ0FBQyxNQUFNLEVBQUU7WUFDWCxPQUFPLEVBQUUsQ0FBQztTQUNYO1FBRUQsTUFBTSxLQUFLLEdBQUcsSUFBSSxHQUFHLEVBQVUsQ0FBQztRQUNoQyxNQUFNLGNBQWMsR0FBRyxJQUFJLENBQUMsa0JBQWtCLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQztRQUNoRSxNQUFNLGdCQUFnQixHQUFHLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDO1FBQ3BFLE1BQU0sY0FBYyxHQUFHLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDO1FBRWhFLHNFQUFzRTtRQUN0RSxxQkFBcUI7UUFDckIsTUFBTSxXQUFXLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQztRQUNyQyxNQUFNLGFBQWEsR0FBRyxRQUFRLENBQUMsU0FBUyxDQUFDO1FBQ3pDLE1BQU0sV0FBVyxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUM7UUFFckMsMEVBQTBFO1FBQzFFLDhCQUE4QjtRQUM5QixPQUNFLE1BQU0sSUFBSSxJQUFJO1lBQ2QsTUFBTSxLQUFLLGNBQWM7WUFDekIsTUFBTSxLQUFLLGdCQUFnQjtZQUMzQixNQUFNLEtBQUssY0FBYztZQUN6QixNQUFNLEtBQUssV0FBVztZQUN0QixNQUFNLEtBQUssYUFBYTtZQUN4QixNQUFNLEtBQUssV0FBVyxFQUN0QjtZQUNBLE1BQU0sUUFBUSxHQUFHLE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUVwRCxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsUUFBUSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtnQkFDeEMsTUFBTSxJQUFJLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUV6QixJQUFJLENBQUMsY0FBYyxDQUFDLE1BQU0sRUFBRSxJQUFLLENBQUMsRUFBRTtvQkFDbEMsTUFBTSxRQUFRLEdBQUcsTUFBTSxDQUFDLHdCQUF3QixDQUFDLE1BQU0sRUFBRSxJQUFLLENBQUMsQ0FBQztvQkFDaEUsSUFDRSxDQUFDLFFBQVEsS0FBSyxTQUFTLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDO3dCQUN6QyxNQUFNLENBQUMsWUFBWSxDQUFDLEVBQ3BCO3dCQUNBLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSyxDQUFDLENBQUM7cUJBQ2xCO2lCQUNGO2FBQ0Y7WUFFRCxNQUFNLEdBQUcsTUFBTSxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUMsQ0FBQztTQUN4QztRQUVELE9BQU8sS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUMzQixDQUFDO0lBRU8saUJBQWlCLENBQUMsQ0FBTztRQUMvQixJQUFJLE1BQU0sR0FBRyxJQUFJLENBQUMsbUJBQW1CLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzdDLElBQUksQ0FBQyxNQUFNLEVBQUU7WUFDWCxNQUFNLEdBQUcsSUFBSSxDQUFDLGtCQUFrQixFQUFFLENBQUM7WUFDbkMsSUFBSSxDQUFDLG1CQUFtQixDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUM7U0FDekM7UUFDRCxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDO0lBRU8sZ0JBQWdCLENBQ3RCLENBQVU7UUFFVixJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNuQyxJQUFJLENBQUMsS0FBSyxFQUFFO1lBQ1YsS0FBSyxHQUFHLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1lBQ2pDLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQztTQUMvQjtRQUNELElBQUksS0FBSyxDQUFDLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1lBQzFCLEtBQUssQ0FBQyxRQUFRLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUUsQ0FBQztTQUN2RDtRQUNELE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQUVPLGtCQUFrQjtRQUN4QixPQUFPO1lBQ0wsUUFBUSxFQUFFLFNBQVM7WUFDbkIsUUFBUSxFQUFFLFdBQVc7WUFDckIsaUJBQWlCLEVBQUUsRUFBRTtTQUN0QixDQUFDO0lBQ0osQ0FBQztJQUVPLGlCQUFpQjtRQUN2QixPQUFPO1lBQ0wsS0FBSyxFQUFFLEVBQUU7WUFDVCxRQUFRLEVBQUUsRUFBRTtZQUNaLFNBQVMsRUFBRSxFQUFFO1lBQ2IsbUJBQW1CLEVBQUUsRUFBRTtZQUN2QixPQUFPLEVBQUUsRUFBRTtTQUNaLENBQUM7SUFDSixDQUFDO0lBc0JPLGNBQWMsQ0FDcEIsUUFBeUIsRUFDekIsT0FBb0I7UUFFcEIsSUFBSSxRQUFRLENBQUMsSUFBSSxLQUFLLFFBQVEsRUFBRTtZQUM5QixPQUFPLElBQUksSUFBSSxDQUFDLGtCQUFrQixDQUFDLE1BQU0sRUFBRSxDQUFDO1NBQzdDO2FBQU0sSUFBSSxRQUFRLENBQUMsSUFBSSxLQUFLLE9BQU8sRUFBRTtZQUNwQyxPQUFPLElBQUksSUFBSSxDQUFDLGtCQUFrQixDQUFDLEtBQUssRUFBRSxDQUFDO1NBQzVDO2FBQU0sSUFBSSxRQUFRLENBQUMsSUFBSSxLQUFLLFFBQVEsRUFBRTtZQUNyQyxPQUFPLElBQUksSUFBSSxDQUFDLGtCQUFrQixDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQztTQUMvQzthQUFNLElBQ0wsUUFBUSxDQUFDLElBQUksS0FBSyxVQUFVO1lBQzVCLFFBQVEsQ0FBQyxJQUFJLEtBQUssWUFBWTtZQUM5QixRQUFRLENBQUMsSUFBSSxLQUFLLE1BQU07WUFDeEIsUUFBUSxDQUFDLElBQUksS0FBSyxXQUFXLEVBQzdCO1lBQ0EsT0FBTyxRQUFRLENBQUMsS0FBSyxDQUFDO1NBQ3ZCO2FBQU0sSUFBSSxRQUFRLENBQUMsSUFBSSxLQUFLLFVBQVUsRUFBRTtZQUN2QyxNQUFNLFNBQVMsR0FDYixDQUFDLFFBQVEsQ0FBQyxPQUFPO2dCQUNmLFFBQVEsQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDO2dCQUM3QixRQUFRLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDLE9BQU8sQ0FBQztnQkFDeEMsRUFBRSxDQUFDO1lBQ0wsTUFBTSxjQUFjLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUNqRCw0REFBNEQ7WUFDNUQsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDO1lBQ3BCLE1BQU0sZUFBZSxHQUFHLFVBQVUsQ0FBQyxVQUVqQyxHQUFHLElBQW1CO2dCQUV0QixNQUFNLFNBQVMsR0FBRyxNQUFNLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQzdDLE1BQU0sVUFBVSxHQUFHLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDL0MsU0FBUyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQy9CLFNBQVMsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUM5QixTQUFTLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztnQkFDM0IsaUVBQWlFO2dCQUNqRSxrRUFBa0U7Z0JBQ2xFLGtFQUFrRTtnQkFDbEUsZUFBZTtnQkFDZixNQUFNLFVBQVUsR0FBdUI7b0JBQ3JDLElBQUksRUFBRSxZQUFZO29CQUNsQixLQUFLLEVBQUUsU0FBUztpQkFDakIsQ0FBQztnQkFDRixTQUFTLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztnQkFDbkMsU0FBUyxDQUFDLG1CQUFtQixDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsc0JBQXNCLEVBQUUsQ0FBQyxDQUFDO2dCQUVwRSx3RUFBd0U7Z0JBQ3hFLElBQUksZ0JBQWdCLENBQUM7Z0JBQ3JCLHFFQUFxRTtnQkFDckUsSUFBSSxXQUFXLENBQUM7Z0JBQ2hCLHFFQUFxRTtnQkFDckUsb0VBQW9FO2dCQUNwRSw2Q0FBNkM7Z0JBQzdDLElBQUksaUJBQWlCLEdBQUcsS0FBSyxDQUFDO2dCQUU5QixJQUFJO29CQUNGLDhEQUE4RDtvQkFDOUQsbUVBQW1FO29CQUNuRSxpRUFBaUU7b0JBQ2pFLGtDQUFrQztvQkFDbEMsZ0JBQWdCLEdBQUcsQ0FBQyxHQUFHLEVBQUU7d0JBQ3ZCLElBQUksSUFBSSxZQUFZLENBQUMsRUFBRTs0QkFDckIsaURBQWlEOzRCQUNqRCxjQUFjLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUU7Z0NBQzlCLGlEQUFpRDtnQ0FDakQsb0RBQW9EO2dDQUNwRCxnQkFBZ0I7Z0NBQ2hCLElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxFQUFFLElBQUksS0FBSyxVQUFVLEVBQUU7b0NBQ3hDLHNDQUFzQztvQ0FDdEMsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO29DQUM3QixzQ0FBc0M7b0NBQ3RDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxNQUFNLENBQUMsb0JBQW9CLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7b0NBQzFELHNDQUFzQztvQ0FDdEMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLFVBQVUsR0FBRyxTQUFTLENBQUM7aUNBQ25DOzRCQUNILENBQUMsQ0FBQyxDQUFDOzRCQUVILDBDQUEwQzs0QkFDMUMsTUFBTSxRQUFRLEdBQUcsVUFBVSxDQUFDLGlCQUFpQixDQUFDLE1BQU07Z0NBQ2xELENBQUMsQ0FBQyxVQUFVLENBQUMsaUJBQWlCLENBQUMsS0FBSyxFQUFFO2dDQUN0QyxDQUFDLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQzs0QkFDeEIsT0FBTyxRQUFRLElBQUksUUFBUSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7eUJBQ3BEO3dCQUVELGdFQUFnRTt3QkFDaEUsOEJBQThCO3dCQUM5QixJQUFJLGdCQUFnQixHQUFHLFVBQVUsQ0FBQyxpQkFBaUIsQ0FBQyxLQUFLLEVBQUUsQ0FBQzt3QkFDNUQsSUFBSSxnQkFBZ0IsS0FBSyxTQUFTLEVBQUU7NEJBQ2xDLGdCQUFnQixHQUFHLFVBQVUsQ0FBQyxRQUFRLENBQUM7eUJBQ3hDO3dCQUNELElBQUksZ0JBQWdCLEVBQUU7NEJBQ3BCLE9BQU8sZ0JBQWdCLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxTQUFTLENBQUMsQ0FBQzt5QkFDaEQ7d0JBQ0QseUNBQXlDO3dCQUN6QyxJQUFJLENBQUMsQ0FBQyxVQUFVLEVBQUU7NEJBQ2hCLE9BQU8sQ0FBQyxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDO3lCQUM1Qzt3QkFFRCxPQUFPLFNBQVMsQ0FBQztvQkFDbkIsQ0FBQyxDQUFDLEVBQUUsQ0FBQztpQkFDTjtnQkFBQyxPQUFPLEtBQUssRUFBRTtvQkFDZCxnRUFBZ0U7b0JBQ2hFLFdBQVcsR0FBRyxLQUFLLENBQUM7b0JBQ3BCLGlCQUFpQixHQUFHLElBQUksQ0FBQztvQkFDekIsTUFBTSxLQUFLLENBQUM7aUJBQ2I7d0JBQVM7b0JBQ1IscUNBQXFDO29CQUNyQyxrRUFBa0U7b0JBQ2xFLHFFQUFxRTtvQkFDckUsb0RBQW9EO29CQUNwRCw0Q0FBNEM7b0JBQzVDLFVBQVUsQ0FBQyxJQUFJLEdBQUcsaUJBQWlCLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDO29CQUN6RCxVQUFVLENBQUMsS0FBSyxHQUFHLGlCQUFpQixDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLGdCQUFnQixDQUFDO2lCQUN2RTtnQkFFRCxPQUFPLGdCQUFnQixDQUFDO1lBQzFCLENBQUMsRUFDRCxRQUFRLENBQUMsTUFBTSxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBRXRCLE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxRQUFRLEVBQUUsZUFBZSxDQUFTLENBQUM7WUFDdEUsQ0FBQyxDQUFDLGVBQWUsR0FBRyxJQUFJLENBQUM7WUFDekIsQ0FBQyxDQUFDLHFCQUFxQixHQUFHLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFhLENBQUM7WUFFeEUsSUFBSSxPQUFPLE9BQU8sS0FBSyxVQUFVLEVBQUU7Z0JBQ2pDLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDO2FBQzdCO1lBRUQsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDLENBQUM7WUFDakQsSUFBSSxDQUFDLG1CQUFtQixDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLGtCQUFrQixFQUFFLENBQUMsQ0FBQztZQUUzRCxNQUFNLENBQUMsY0FBYyxDQUFDLENBQUMsRUFBRSxNQUFNLEVBQUU7Z0JBQy9CLFlBQVksRUFBRSxLQUFLO2dCQUNuQixVQUFVLEVBQUUsSUFBSTtnQkFDaEIsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUM7Z0JBQ25DLEdBQUcsRUFBRSxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQzthQUMxQyxDQUFDLENBQUM7WUFFSCxDQUFDLENBQUMsU0FBUyxHQUFHLEdBQUcsRUFBRTtnQkFDakIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQzFCLE9BQU8sQ0FBQyxDQUFDO1lBQ1gsQ0FBQyxDQUFDO1lBRUYsQ0FBQyxDQUFDLFNBQVMsR0FBRyxHQUFHLEVBQUU7Z0JBQ2pCLENBQUMsQ0FBQyxTQUFTLEVBQUUsQ0FBQztnQkFDZCxJQUFJLENBQUMsbUJBQW1CLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNuQyxPQUFPLENBQUMsQ0FBQztZQUNYLENBQUMsQ0FBQztZQUVGLENBQUMsQ0FBQyxXQUFXLEdBQUcsR0FBRyxFQUFFO2dCQUNuQixDQUFDLENBQUMsU0FBUyxFQUFFLENBQUM7Z0JBQ2QsT0FBTyxPQUFPLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUM7WUFDekMsQ0FBQyxDQUFDO1lBRUYsQ0FBQyxDQUFDLG1CQUFtQixHQUFHLENBQUMsS0FBb0IsRUFBRSxFQUFFO1lBQy9DLG9FQUFvRTtZQUNwRSxDQUFDLENBQUMsc0JBQXNCLENBQUMsR0FBRyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUM7WUFFeEMsQ0FBQyxDQUFDLHFCQUFxQixHQUFHLENBQUMsS0FBcUIsRUFBRSxFQUFFLENBQ2xELENBQUMsQ0FBQyxzQkFBc0IsQ0FBQyxHQUFHLEVBQUUsQ0FDNUIsSUFBSSxDQUFDLGtCQUFrQixDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQy9DLENBQUM7WUFFSixDQUFDLENBQUMscUJBQXFCLEdBQUcsQ0FBQyxLQUFjLEVBQUUsRUFBRSxDQUMzQyxDQUFDLENBQUMsc0JBQXNCLENBQUMsR0FBRyxFQUFFLENBQzVCLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUM5QyxDQUFDO1lBRUosQ0FBQyxDQUFDLGVBQWUsR0FBRyxDQUFDLEtBQW9CLEVBQUUsRUFBRTtZQUMzQyxvRUFBb0U7WUFDcEUsQ0FBQyxDQUFDLGtCQUFrQixDQUFDLEdBQUcsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBRXBDLENBQUMsQ0FBQyxpQkFBaUIsR0FBRyxDQUFDLEtBQXFCLEVBQUUsRUFBRSxDQUM5QyxDQUFDLENBQUMsa0JBQWtCLENBQUMsR0FBRyxFQUFFLENBQ3hCLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUMvQyxDQUFDO1lBRUosQ0FBQyxDQUFDLGlCQUFpQixHQUFHLENBQUMsS0FBYyxFQUFFLEVBQUUsQ0FDdkMsQ0FBQyxDQUFDLGtCQUFrQixDQUFDLEdBQUcsRUFBRSxDQUN4QixJQUFJLENBQUMsa0JBQWtCLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FDOUMsQ0FBQztZQUVKLENBQUMsQ0FBQyxzQkFBc0IsR0FBRyxDQUFDLEVBQUssRUFBRSxFQUFFO2dCQUNuQyxvRUFBb0U7Z0JBQ3BFLDhDQUE4QztnQkFDOUMsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUM3QyxVQUFVLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO2dCQUN0QyxPQUFPLENBQUMsQ0FBQztZQUNYLENBQUMsQ0FBQztZQUVGLENBQUMsQ0FBQyxrQkFBa0IsR0FBRyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7WUFPckQsU0FBUyxrQkFBa0IsQ0FFekIsRUFBSyxFQUNMLFFBQWlEO2dCQUVqRCwwREFBMEQ7Z0JBQzFELE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDN0MsTUFBTSxzQkFBc0IsR0FBRyxVQUFVLENBQUMsUUFBUSxDQUFDO2dCQUNuRCxNQUFNLCtCQUErQixHQUFHLFVBQVUsQ0FBQyxpQkFBaUIsQ0FBQztnQkFDckUsVUFBVSxDQUFDLFFBQVEsR0FBRyxFQUFFLENBQUM7Z0JBQ3pCLFVBQVUsQ0FBQyxpQkFBaUIsR0FBRyxFQUFFLENBQUM7Z0JBRWxDLE1BQU0sYUFBYSxHQUFHLFFBQVEsRUFBRSxDQUFDO2dCQUVqQyxJQUFJLFNBQVMsQ0FBQyxhQUFhLENBQUMsRUFBRTtvQkFDNUIsT0FBTyxhQUFhLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRTt3QkFDN0IsVUFBVSxDQUFDLFFBQVEsR0FBRyxzQkFBc0IsQ0FBQzt3QkFDN0MsVUFBVSxDQUFDLGlCQUFpQixHQUFHLCtCQUErQixDQUFDO29CQUNqRSxDQUFDLENBQUMsQ0FBQztpQkFDSjtxQkFBTTtvQkFDTCxVQUFVLENBQUMsUUFBUSxHQUFHLHNCQUFzQixDQUFDO29CQUM3QyxVQUFVLENBQUMsaUJBQWlCLEdBQUcsK0JBQStCLENBQUM7aUJBQ2hFO1lBQ0gsQ0FBQztZQUVELENBQUMsQ0FBQyxrQkFBa0IsR0FBRyxDQUFDLEVBQUssRUFBRSxFQUFFO2dCQUMvQiwrREFBK0Q7Z0JBQy9ELE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDN0MsVUFBVSxDQUFDLFFBQVEsR0FBRyxFQUFFLENBQUM7Z0JBQ3pCLE9BQU8sQ0FBQyxDQUFDO1lBQ1gsQ0FBQyxDQUFDO1lBRUYsQ0FBQyxDQUFDLGNBQWMsR0FBRyxHQUFHLEVBQUUsQ0FDdEIsQ0FBQyxDQUFDLGtCQUFrQixDQUFDO2dCQUNuQixPQUFPLElBQUksQ0FBQztZQUNkLENBQUMsQ0FBQyxDQUFDO1lBRUwsQ0FBQyxDQUFDLFFBQVEsR0FBRyxDQUFDLElBQVksRUFBRSxFQUFFO2dCQUM1QixJQUFJLElBQUksRUFBRTtvQkFDUixNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxDQUFDLENBQUM7b0JBQzdDLFVBQVUsQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDO2lCQUM1QjtnQkFDRCxPQUFPLENBQUMsQ0FBQztZQUNYLENBQUMsQ0FBQztZQUVGLENBQUMsQ0FBQyxXQUFXLEdBQUcsR0FBRyxFQUFFO2dCQUNuQixNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQzdDLE9BQU8sVUFBVSxDQUFDLFFBQVEsSUFBSSxXQUFXLENBQUM7WUFDNUMsQ0FBQyxDQUFDO1lBRUYsSUFBSSxRQUFRLENBQUMsUUFBUSxFQUFFO2dCQUNyQixDQUFDLENBQUMsa0JBQWtCLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDO2FBQ3pDO1lBRUQsT0FBTyxDQUFDLENBQUM7U0FDVjthQUFNO1lBQ0wsTUFBTSxXQUFXLEdBQUcsUUFBUSxDQUFDLElBQUksSUFBSSxnQkFBZ0IsQ0FBQztZQUN0RCxNQUFNLElBQUksS0FBSyxDQUFDLHFCQUFxQixXQUFXLEVBQUUsQ0FBQyxDQUFDO1NBQ3JEO0lBQ0gsQ0FBQztJQUVPLG1CQUFtQixDQUN6QixRQUF5QixFQUN6QixlQUF5QjtRQUV6QixJQUFJLElBQUksR0FBRyxRQUFRLENBQUMsSUFBSSxDQUFDO1FBQ3pCLElBQUksQ0FBQyxJQUFJLEVBQUU7WUFDVCxPQUFPLGVBQWUsQ0FBQztTQUN4QjtRQUVELCtDQUErQztRQUMvQyxNQUFNLG1CQUFtQixHQUFHLFFBQVEsQ0FBQztRQUNyQyxJQUFJLFFBQVEsR0FBRyxFQUFFLENBQUM7UUFDbEIsdUVBQXVFO1FBQ3ZFLElBQUksSUFBSSxDQUFDLFVBQVUsQ0FBQyxtQkFBbUIsQ0FBQyxFQUFFO1lBQ3hDLEdBQUc7Z0JBQ0QsSUFBSSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsbUJBQW1CLENBQUMsTUFBTSxDQUFDLENBQUM7Z0JBQ2xELCtDQUErQztnQkFDL0MsUUFBUSxHQUFHLGFBQWEsQ0FBQzthQUMxQixRQUFRLElBQUksSUFBSSxJQUFJLENBQUMsVUFBVSxDQUFDLG1CQUFtQixDQUFDLEVBQUU7U0FDeEQ7UUFFRCw2RUFBNkU7UUFDN0UsSUFBSSxJQUFJLEtBQUsscUJBQXFCLEVBQUU7WUFDbEMsT0FBTyxlQUFlLENBQUM7U0FDeEI7UUFFRDtRQUNFLDBFQUEwRTtRQUMxRSxpQkFBaUIsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDO1lBQzNCLHFGQUFxRjtZQUNyRixLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUNoQjtZQUNBLElBQUksR0FBRyxJQUFJLElBQUksRUFBRSxDQUFDO1NBQ25CO1FBRUQsMEVBQTBFO1FBQzFFLHdCQUF3QjtRQUN4QixJQUFJLDhCQUE4QixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUM3QyxJQUFJLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyw4QkFBOEIsRUFBRSxHQUFHLENBQUMsQ0FBQztTQUMxRDtRQUVELE1BQU0sSUFBSSxHQUNSLG1CQUFtQixJQUFJLE1BQU07WUFDN0IsWUFBWSxxQkFBcUIseUJBQXlCO1lBQzFELElBQUksUUFBUSxFQUFFLENBQUM7UUFDakIsTUFBTSxpQkFBaUIsR0FBRyxJQUFJLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxRQUFRLENBQzVELHFCQUFxQixFQUNyQixJQUFJLENBQ0wsQ0FBQztRQUVGLE9BQU8saUJBQWlCLENBQUMsZUFBZSxDQUFDLENBQUM7SUFDNUMsQ0FBQztJQUVPLGFBQWEsQ0FDbkIsUUFBeUIsRUFDekIsU0FBMEIsRUFDMUIsSUFHQztRQUVELHFFQUFxRTtRQUNyRSx1REFBdUQ7UUFDdkQsb0RBQW9EO1FBQ3BELE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDM0MsSUFBSSxRQUFRLENBQUMsS0FBSyxJQUFJLElBQUksRUFBRTtZQUMxQixJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxHQUFHLElBQUksQ0FBQztTQUM3QjtRQUVELElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFO1lBQ2hELE1BQU0sWUFBWSxHQUFHLENBQUMsUUFBUSxDQUFDLE9BQU8sSUFBSSxRQUFRLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDO1lBQ3hFLElBQUksWUFBWSxDQUFDLEdBQUcsSUFBSSxJQUFJLEVBQUU7Z0JBQzVCLFNBQVMsQ0FBQyxJQUFJLENBQ1osQ0FBQyxVQUFVLEdBQUc7b0JBQ1osT0FBTyxHQUFHLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztnQkFDeEMsQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxDQUNyQixDQUFDO2FBQ0g7aUJBQU07Z0JBQ0wsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsWUFBWSxFQUFFLFNBQVMsRUFBRSxJQUFJLENBQUMsQ0FBQzthQUNoRTtRQUNILENBQUMsQ0FBQyxDQUFDO1FBRUgsSUFDRSxRQUFRLENBQUMsSUFBSSxLQUFLLFdBQVc7WUFDN0IsUUFBUSxDQUFDLElBQUksS0FBSyxNQUFNO1lBQ3hCLElBQUksQ0FBQyxXQUFXLENBQUM7WUFDakIsT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssUUFBUSxFQUNyQztZQUNBLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDO1NBQ3RDO1FBRUQsT0FBTyxJQUFpQixDQUFDO0lBQzNCLENBQUM7SUFFRDs7T0FFRztJQUNLLHFCQUFxQixDQUMzQixNQUFTLEVBQ1QsV0FBYztRQUVkLEtBQUssTUFBTSxRQUFRLElBQUksSUFBSSxDQUFDLFNBQVMsRUFBRTtZQUNyQyxJQUNFLFFBQVEsSUFBSSxRQUFRO2dCQUNwQixVQUFVLElBQUksUUFBUTtnQkFDdEIsUUFBUSxDQUFDLE1BQU0sS0FBSyxNQUFNO2dCQUMxQixRQUFRLENBQUMsUUFBUSxLQUFLLFdBQVcsRUFDakM7Z0JBQ0EsT0FBTyxRQUEwQyxDQUFDO2FBQ25EO1NBQ0Y7UUFFRCxPQUFPO0lBQ1QsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxvQkFBb0IsQ0FBSSxRQUF5QjtRQUMvQyxNQUFNLFNBQVMsR0FBb0IsRUFBRSxDQUFDO1FBQ3RDLE1BQU0sSUFBSSxHQUFHLEVBQUUsQ0FBQztRQUNoQixNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFJLFFBQVEsRUFBRSxTQUFTLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDOUQsU0FBUyxDQUFDLE9BQU8sQ0FBQyxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQztRQUN4QyxPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFRDs7O09BR0c7SUFDSCxXQUFXLENBQ1QsU0FBWSxFQUNaLEtBQXNCO1FBRXRCLE1BQU0sSUFBSSxHQUFHLEtBQUssSUFBSSxJQUFJLEdBQUcsRUFBYSxDQUFDO1FBQzNDLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDaEMsSUFBSSxHQUFHLElBQUksSUFBSSxFQUFFO1lBQ2YsT0FBTyxFQUFFLEdBQUcsRUFBRSxDQUFDO1NBQ2hCO1FBRUQsTUFBTSxJQUFJLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ2hDLElBQUksQ0FBQyxJQUFJLEVBQUU7WUFDVCxPQUFPLElBQUksQ0FBQztTQUNiO1FBRUQsTUFBTSxRQUFRLEdBQW9CLEVBQUUsSUFBSSxFQUFFLENBQUM7UUFDM0MsSUFDRSxJQUFJLEtBQUssVUFBVTtZQUNuQixJQUFJLEtBQUssWUFBWTtZQUNyQixJQUFJLEtBQUssV0FBVztZQUNwQixJQUFJLEtBQUssTUFBTSxFQUNmO1lBQ0EsUUFBUSxDQUFDLEtBQUssR0FBRyxTQUFTLENBQUM7WUFDM0IsT0FBTyxRQUFRLENBQUM7U0FDakI7YUFBTSxJQUFJLElBQUksS0FBSyxVQUFVLEVBQUU7WUFDOUIscUVBQXFFO1lBQ3JFLGlKQUFpSjtZQUNqSixNQUFNLGFBQWEsR0FBRyxTQUFTLENBQUMsSUFBSSxDQUFDO1lBQ3JDLElBQUksT0FBTyxhQUFhLEtBQUssUUFBUSxFQUFFO2dCQUNyQyxRQUFRLENBQUMsSUFBSSxHQUFHLGFBQWEsQ0FBQzthQUMvQjtZQUNELElBQUksSUFBSSxDQUFDLGNBQWMsQ0FBQyxTQUFTLENBQUMsRUFBRTtnQkFDbEMsUUFBUSxDQUFDLFFBQVEsR0FBRyxTQUFTLENBQUMscUJBQXFCLEVBQU8sQ0FBQzthQUM1RDtTQUNGO1FBRUQsUUFBUSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDO1FBQzNCLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxFQUFFLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUVwQyxJQUFJLE9BQU8sR0FBMkMsSUFBSSxDQUFDO1FBQzNELHFCQUFxQjtRQUNyQixJQUFJLElBQUksS0FBSyxPQUFPLEVBQUU7WUFDcEIsdUNBQXVDO1lBQ3ZDLElBQUksQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUU7Z0JBQ3pDLElBQ0UsSUFBSSxLQUFLLFVBQVU7b0JBQ25CLElBQUksQ0FBQyxjQUFjLENBQUMsU0FBUyxDQUFDO29CQUM5QixJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxFQUNuQjtvQkFDQSxPQUFPO2lCQUNSO2dCQUNELHNDQUFzQztnQkFDdEMsTUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBSSxTQUFTLENBQUMsSUFBSSxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7Z0JBQ2hFLElBQUksWUFBWSxFQUFFO29CQUNoQixJQUFJLENBQUMsT0FBTyxFQUFFO3dCQUNaLE9BQU8sR0FBRyxFQUFFLENBQUM7cUJBQ2Q7b0JBQ0QsT0FBTyxDQUFDLElBQUksQ0FBQyxHQUFHLFlBQVksQ0FBQztpQkFDOUI7WUFDSCxDQUFDLENBQUMsQ0FBQztTQUNKO1FBRUQsSUFBSSxPQUFPLEVBQUU7WUFDWCxRQUFRLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztTQUM1QjtRQUVELE9BQU8sUUFBUSxDQUFDO0lBQ2xCLENBQUM7SUFTRCxjQUFjLENBQUMsRUFBVztRQUN4QixPQUFPLEVBQUUsSUFBSSxJQUFJLElBQUssRUFBVyxDQUFDLGVBQWUsS0FBSyxJQUFJLENBQUM7SUFDN0QsQ0FBQztJQUVELEVBQUUsQ0FBMkMsY0FBa0I7UUFDN0QsTUFBTSxNQUFNLEdBQUcsY0FBYyxDQUFDLENBQUMsQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDMUQsTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBSTtZQUNoQyxNQUFNO1lBQ04sSUFBSSxFQUFFLFVBQVU7U0FDakIsQ0FBQyxDQUFDO1FBQ0gsSUFBSSxjQUFjLEVBQUU7WUFDbEIsRUFBRSxDQUFDLGtCQUFrQixDQUFDLGNBQWMsQ0FBQyxDQUFDO1NBQ3ZDO1FBQ0QsT0FBTyxFQUFFLENBQUM7SUFDWixDQUFDO0lBMEJELEtBQUssQ0FDSCxNQUFTLEVBQ1QsU0FBa0IsRUFDbEIsVUFBMEI7UUFFMUIsSUFDRSxNQUFNLElBQUksSUFBSTtZQUNkLENBQUMsT0FBTyxNQUFNLEtBQUssUUFBUSxJQUFJLE9BQU8sTUFBTSxLQUFLLFVBQVUsQ0FBQyxFQUM1RDtZQUNBLE1BQU0sSUFBSSxLQUFLLENBQ2IsMENBQTBDLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FDdkUsQ0FBQztTQUNIO1FBRUQsSUFBSSxTQUFTLElBQUksSUFBSSxFQUFFO1lBQ3JCLE1BQU0sSUFBSSxLQUFLLENBQUMsMkJBQTJCLENBQUMsQ0FBQztTQUM5QztRQUVELElBQUksVUFBVSxFQUFFO1lBQ2QsT0FBTyxJQUFJLENBQUMsY0FBYyxDQUFDLE1BQU0sRUFBRSxTQUFTLEVBQUUsVUFBVSxDQUFDLENBQUM7U0FDM0Q7UUFFRCxNQUFNLFFBQVEsR0FBRyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUM7UUFFbkMsSUFBSSxDQUFDLFFBQVEsRUFBRTtZQUNiLE1BQU0sSUFBSSxLQUFLLENBQ2IsY0FBYyxNQUFNLENBQ2xCLFNBQVMsQ0FDViwwQ0FBMEMsQ0FDNUMsQ0FBQztTQUNIO1FBRUQsSUFBSSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsUUFBUSxDQUFDLEVBQUU7WUFDbEMsSUFBSSxPQUFPLFFBQVEsS0FBSyxVQUFVLEVBQUU7Z0JBQ2xDLE1BQU0sSUFBSSxLQUFLLENBQ2IsdUJBQXVCLE1BQU0sQ0FDM0IsU0FBUyxDQUNWLDZDQUE2QyxJQUFJLENBQUMsT0FBTyxDQUN4RCxRQUFRLENBQ1Qsa0JBQ0MsT0FBTyxRQUFRLEtBQUssUUFBUTtvQkFDMUIsQ0FBQyxDQUFDLDhFQUE4RSxNQUFNLENBQ2xGLFNBQVMsQ0FDVixzQkFBc0I7b0JBQ3pCLENBQUMsQ0FBQyxFQUNOLEVBQUUsQ0FDSCxDQUFDO2FBQ0g7WUFFRCxNQUFNLGFBQWEsR0FBRyxNQUFNLENBQUMsU0FBUyxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQ3hELE1BQU0sRUFDTixTQUFTLENBQ1YsQ0FBQztZQUVGLElBQUksVUFBVSxHQUFHLE1BQU0sQ0FBQyx3QkFBd0IsQ0FBQyxNQUFNLEVBQUUsU0FBUyxDQUFDLENBQUM7WUFDcEUsSUFBSSxLQUFLLEdBQUcsTUFBTSxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUUxQyxPQUFPLENBQUMsVUFBVSxJQUFJLEtBQUssS0FBSyxJQUFJLEVBQUU7Z0JBQ3BDLFVBQVUsR0FBRyxNQUFNLENBQUMsd0JBQXdCLENBQUMsS0FBSyxFQUFFLFNBQVMsQ0FBQyxDQUFDO2dCQUMvRCxLQUFLLEdBQUcsTUFBTSxDQUFDLGNBQWMsQ0FBQyxLQUFLLENBQUMsQ0FBQzthQUN0QztZQUVELElBQUksSUFBVSxDQUFDO1lBRWYsSUFBSSxVQUFVLElBQUksVUFBVSxDQUFDLEdBQUcsRUFBRTtnQkFDaEMsTUFBTSxXQUFXLEdBQUcsVUFBVSxDQUFDLEdBQUcsQ0FBQztnQkFDbkMsSUFBSSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsRUFBRSxJQUFJLEVBQUUsVUFBVSxFQUFFLEVBQUUsR0FBRyxFQUFFO29CQUNwRCxVQUFXLENBQUMsR0FBRyxHQUFHLFdBQVcsQ0FBQztvQkFDOUIsTUFBTSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsU0FBUyxFQUFFLFVBQVcsQ0FBQyxDQUFDO2dCQUN4RCxDQUFDLENBQUMsQ0FBQztnQkFDSCxVQUFVLENBQUMsR0FBRyxHQUFHLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQztnQkFDNUIsTUFBTSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsU0FBUyxFQUFFLFVBQVUsQ0FBQyxDQUFDO2FBQ3REO2lCQUFNO2dCQUNMLElBQUksR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLEVBQUUsSUFBSSxFQUFFLFVBQVUsRUFBRSxFQUFFLEdBQUcsRUFBRTtvQkFDcEQsSUFBSSxhQUFhLEVBQUU7d0JBQ2pCLE1BQU0sQ0FBQyxTQUFTLENBQUMsR0FBRyxRQUFRLENBQUM7cUJBQzlCO3lCQUFNO3dCQUNMLE9BQU8sTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDO3FCQUMxQjtnQkFDSCxDQUFDLENBQUMsQ0FBQztnQkFDSCwwREFBMEQ7Z0JBQzFELE1BQU0sQ0FBQyxTQUFTLENBQUMsR0FBRyxJQUFJLENBQUM7YUFDMUI7WUFFRCxJQUFJLENBQUMsa0JBQWtCLENBQUM7Z0JBQ3RCLE9BQU8sUUFBUSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7WUFDekMsQ0FBQyxDQUFDLENBQUM7U0FDSjtRQUVELE9BQU8sTUFBTSxDQUFDLFNBQVMsQ0FBUyxDQUFDO0lBQ25DLENBQUM7SUFFTyxjQUFjLENBQ3BCLE1BQVMsRUFDVCxXQUFvQixFQUNwQixVQUF5QjtRQUV6QixJQUFJLFVBQVUsR0FBRyxNQUFNLENBQUMsd0JBQXdCLENBQUMsTUFBTSxFQUFFLFdBQVcsQ0FBQyxDQUFDO1FBQ3RFLElBQUksS0FBSyxHQUFHLE1BQU0sQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFMUMsT0FBTyxDQUFDLFVBQVUsSUFBSSxLQUFLLEtBQUssSUFBSSxFQUFFO1lBQ3BDLFVBQVUsR0FBRyxNQUFNLENBQUMsd0JBQXdCLENBQUMsS0FBSyxFQUFFLFdBQVcsQ0FBQyxDQUFDO1lBQ2pFLEtBQUssR0FBRyxNQUFNLENBQUMsY0FBYyxDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQ3RDO1FBRUQsSUFBSSxDQUFDLFVBQVUsRUFBRTtZQUNmLE1BQU0sSUFBSSxLQUFLLENBQ2IsY0FBYyxNQUFNLENBQ2xCLFdBQVcsQ0FDWiwwQ0FBMEMsQ0FDNUMsQ0FBQztTQUNIO1FBRUQsSUFBSSxDQUFDLFVBQVUsQ0FBQyxZQUFZLEVBQUU7WUFDNUIsTUFBTSxJQUFJLEtBQUssQ0FDYixjQUFjLE1BQU0sQ0FBQyxXQUFXLENBQUMsaUNBQWlDLENBQ25FLENBQUM7U0FDSDtRQUVELElBQUksQ0FBQyxVQUFVLENBQUMsVUFBVSxDQUFDLEVBQUU7WUFDM0IsTUFBTSxJQUFJLEtBQUssQ0FDYixjQUFjLE1BQU0sQ0FDbEIsV0FBVyxDQUNaLGdDQUFnQyxVQUFVLEVBQUUsQ0FDOUMsQ0FBQztTQUNIO1FBRUQsTUFBTSxRQUFRLEdBQUcsVUFBVSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBRXhDLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLFFBQVEsQ0FBQyxFQUFFO1lBQ2xDLElBQUksT0FBTyxRQUFRLEtBQUssVUFBVSxFQUFFO2dCQUNsQyxNQUFNLElBQUksS0FBSyxDQUNiLHFCQUFxQixNQUFNLENBQ3pCLFdBQVcsQ0FDWiwyQ0FBMkMsSUFBSSxDQUFDLE9BQU8sQ0FDdEQsUUFBUSxDQUNULGtCQUNDLE9BQU8sUUFBUSxLQUFLLFFBQVE7b0JBQzFCLENBQUMsQ0FBQyw4RUFBOEUsTUFBTSxDQUNsRixXQUFXLENBQ1osc0JBQXNCO29CQUN6QixDQUFDLENBQUMsRUFDTixFQUFFLENBQ0gsQ0FBQzthQUNIO1lBRUQsVUFBVSxDQUFDLFVBQVUsQ0FBQyxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsRUFBRSxJQUFJLEVBQUUsVUFBVSxFQUFFLEVBQUUsR0FBRyxFQUFFO2dCQUN0RSx1Q0FBdUM7Z0JBQ3ZDLFVBQVcsQ0FBQyxVQUFVLENBQUMsR0FBRyxRQUFRLENBQUM7Z0JBQ25DLE1BQU0sQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLFdBQVcsRUFBRSxVQUFXLENBQUMsQ0FBQztZQUMxRCxDQUFDLENBQUMsQ0FBQztZQUVGLFVBQVUsQ0FBQyxVQUFVLENBQVUsQ0FBQyxrQkFBa0IsQ0FBQztnQkFHbEQsbUNBQW1DO2dCQUNuQyxPQUFPLFFBQVEsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDO1lBQ3pDLENBQUMsQ0FBQyxDQUFDO1NBQ0o7UUFFRCxNQUFNLENBQUMsY0FBYyxDQUFDLE1BQU0sRUFBRSxXQUFXLEVBQUUsVUFBVSxDQUFDLENBQUM7UUFDdkQsT0FBTyxVQUFVLENBQUMsVUFBVSxDQUFTLENBQUM7SUFDeEMsQ0FBQztJQUVELGVBQWUsQ0FDYixNQUFTLEVBQ1QsV0FBYyxFQUNkLEtBQVc7UUFFWCxJQUNFLE1BQU0sSUFBSSxJQUFJO1lBQ2QsQ0FBQyxPQUFPLE1BQU0sS0FBSyxRQUFRLElBQUksT0FBTyxNQUFNLEtBQUssVUFBVSxDQUFDLEVBQzVEO1lBQ0EsTUFBTSxJQUFJLEtBQUssQ0FDYixvREFBb0QsSUFBSSxDQUFDLE9BQU8sQ0FDOUQsTUFBTSxDQUNQLFFBQVEsQ0FDVixDQUFDO1NBQ0g7UUFFRCxJQUFJLFdBQVcsSUFBSSxJQUFJLEVBQUU7WUFDdkIsTUFBTSxJQUFJLEtBQUssQ0FBQywyQkFBMkIsQ0FBQyxDQUFDO1NBQzlDO1FBRUQsSUFBSSxVQUFVLEdBQUcsTUFBTSxDQUFDLHdCQUF3QixDQUFDLE1BQU0sRUFBRSxXQUFXLENBQUMsQ0FBQztRQUN0RSxJQUFJLEtBQUssR0FBRyxNQUFNLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQzFDLE9BQU8sQ0FBQyxVQUFVLElBQUksS0FBSyxLQUFLLElBQUksRUFBRTtZQUNwQyxVQUFVLEdBQUcsTUFBTSxDQUFDLHdCQUF3QixDQUFDLEtBQUssRUFBRSxXQUFXLENBQUMsQ0FBQztZQUNqRSxLQUFLLEdBQUcsTUFBTSxDQUFDLGNBQWMsQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUN0QztRQUNELElBQUksQ0FBQyxVQUFVLEVBQUU7WUFDZixNQUFNLElBQUksS0FBSyxDQUNiLGNBQWMsTUFBTSxDQUNsQixXQUFXLENBQ1osMENBQTBDLENBQzVDLENBQUM7U0FDSDtRQUNELElBQUksQ0FBQyxVQUFVLENBQUMsWUFBWSxFQUFFO1lBQzVCLE1BQU0sSUFBSSxLQUFLLENBQ2IsY0FBYyxNQUFNLENBQUMsV0FBVyxDQUFDLGlDQUFpQyxDQUNuRSxDQUFDO1NBQ0g7UUFFRCxJQUFJLFVBQVUsQ0FBQyxHQUFHLEtBQUssU0FBUyxFQUFFO1lBQ2hDLE1BQU0sSUFBSSxLQUFLLENBQ2Isd0JBQXdCLE1BQU0sQ0FDNUIsV0FBVyxDQUNaLGtFQUFrRSxNQUFNLENBQ3ZFLFdBQVcsQ0FDWiw2Q0FBNkMsQ0FDL0MsQ0FBQztTQUNIO1FBRUQsSUFBSSxVQUFVLENBQUMsR0FBRyxLQUFLLFNBQVMsRUFBRTtZQUNoQyxNQUFNLElBQUksS0FBSyxDQUNiLHdCQUF3QixNQUFNLENBQzVCLFdBQVcsQ0FDWixrRUFBa0UsTUFBTSxDQUN2RSxXQUFXLENBQ1osNkNBQTZDLENBQy9DLENBQUM7U0FDSDtRQUVELElBQUksT0FBTyxVQUFVLENBQUMsS0FBSyxLQUFLLFVBQVUsRUFBRTtZQUMxQyxNQUFNLElBQUksS0FBSyxDQUNiLHdCQUF3QixNQUFNLENBQzVCLFdBQVcsQ0FDWixtRUFBbUUsTUFBTSxDQUN4RSxXQUFXLENBQ1osZUFBZSxDQUNqQixDQUFDO1NBQ0g7UUFFRCxNQUFNLGVBQWUsR0FBRyxJQUFJLENBQUMscUJBQXFCLENBQUMsTUFBTSxFQUFFLFdBQVcsQ0FBQyxDQUFDO1FBRXhFLElBQUksZUFBZSxFQUFFO1lBQ25CLE9BQU8sZUFBZSxDQUFDLFFBQVEsQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDckQ7UUFFRCxNQUFNLGVBQWUsR0FBRyxNQUFNLENBQUMsU0FBUyxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQzFELE1BQU0sRUFDTixXQUFXLENBQ1osQ0FBQztRQUNGLE1BQU0sYUFBYSxHQUFHLFVBQVUsQ0FBQyxLQUFLLENBQUM7UUFFdkMsTUFBTSxPQUFPLEdBQW1DLEdBQUcsRUFBRTtZQUNuRCxJQUFJLGVBQWUsRUFBRTtnQkFDbkIsTUFBTSxDQUFDLFdBQVcsQ0FBQyxHQUFHLGFBQWEsQ0FBQzthQUNyQztpQkFBTTtnQkFDTCxPQUFPLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQzthQUM1QjtRQUNILENBQUMsQ0FBQztRQUVGLE1BQU0sUUFBUSxHQUFtQjtZQUMvQixZQUFZLEVBQUUsQ0FBQyxLQUFLLEVBQUUsRUFBRTtnQkFDdEIsTUFBTSxDQUFDLFdBQVcsQ0FBQyxHQUFHLEtBQUssQ0FBQztnQkFFNUIsT0FBTyxRQUFRLENBQUM7WUFDbEIsQ0FBQztZQUVELE9BQU8sRUFBRSxHQUFHLEVBQUU7Z0JBQ1osT0FBTyxFQUFFLENBQUM7Z0JBRVYsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDakMsQ0FBQztTQUNGLENBQUM7UUFFRixPQUFPLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztRQUN4QixPQUFPLENBQUMsUUFBUSxHQUFHLFdBQVcsQ0FBQztRQUMvQixPQUFPLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztRQUU1QixJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUU1QixPQUFPLFFBQVEsQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDdEMsQ0FBQztJQUVELGFBQWE7UUFDWCxJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksT0FBTyxFQUFFLENBQUM7SUFDbEMsQ0FBQztJQUVELGFBQWE7UUFDWCxJQUFJLENBQUMsbUJBQW1CLEdBQUcsSUFBSSxPQUFPLEVBQUUsQ0FBQztRQUN6QyxJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksT0FBTyxFQUFFLENBQUM7SUFDbEMsQ0FBQztJQUVELGVBQWU7UUFDYixJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQztRQUMvQyxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksR0FBRyxFQUFFLENBQUM7SUFDN0IsQ0FBQztJQUVPLE9BQU8sQ0FBQyxLQUFjO1FBQzVCLE9BQU8sS0FBSyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUMsT0FBTyxLQUFLLENBQUM7SUFDbkQsQ0FBQztJQU9ELE1BQU0sQ0FDSixNQUFTLEVBQ1QsUUFBK0I7UUFFL0IsT0FBTyxNQUFzQyxDQUFDO0lBQ2hELENBQUM7Q0FDRjtBQTU2QkQsb0NBNDZCQztBQUVELE1BQU0sUUFBUSxHQUFHLElBQUksWUFBWSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0FBRWpDLFFBQUEsRUFBRSxHQUFHLFFBQVEsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQ2hDLFFBQUEsS0FBSyxHQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQ3RDLFFBQUEsTUFBTSxHQUFHLFFBQVEsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQ3hDLFFBQUEsZUFBZSxHQUFHLFFBQVEsQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDIn0=