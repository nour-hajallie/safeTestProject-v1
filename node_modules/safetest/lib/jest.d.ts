/// <reference types="jest" />
import 'setimmediate';
import { type Mock as JestMock } from './jest-mock';
import { browserMock } from './browser-mock';
type Mock<R, A extends any[]> = JestMock<(...args: A) => R>;
declare const setTimeout: (timeout: number) => void;
declare const exportedDescribe: jest.Describe;
declare const exportedIt: jest.It & {
    debug: jest.It;
};
declare const retryTimes: (numRetries: number) => typeof jest | undefined;
declare const exportedExpect: <T>(actual: T) => 0 extends 1 & T ? import("./playwright-types").Matchers<T> : T extends import("./browser-mock").BrowserSpy<any, any[]> ? "Browser mocks need to be awaited. Try changing `expect(spy)` to `expect(await spy)`" : import("./playwright-types").Matchers<T>;
interface OverrideInfo<Args extends unknown[], Return> {
    /** The arguments passed to the function */
    args: Args;
    returned: Return;
    /** The original spied on function */
    original: Fn<Args, Return>;
}
type Fn<Args extends unknown[], R> = (...args: Args) => R;
type OverrideFn<Args extends unknown[], Return> = (callback: (info: OverrideInfo<Args, Return>) => Return) => BrowserSpy<any, any[]>;
export type BrowserSpy<Return, Args extends unknown[]> = Mock<Return, Args> & {
    override: OverrideFn<Args, Return>;
    overrideOnce: OverrideFn<Args, Return>;
} & Promise<Mock<Return, Args>>;
export declare const spied: <T extends Fn<unknown[], unknown>>(fn: T) => (T extends Fn<infer Args extends unknown[], infer Return> ? BrowserSpy<Return, Args> : never) & T;
export { exportedDescribe as describe, exportedIt as it, exportedIt as test, setTimeout, retryTimes, exportedExpect as expect, browserMock, };
//# sourceMappingURL=jest.d.ts.map