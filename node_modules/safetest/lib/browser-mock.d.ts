import { type Mock as JestMock } from './jest-mock';
type Mock<R, A extends any[]> = JestMock<(...args: A) => R>;
interface OverrideInfo<Args extends unknown[], Return> {
    /** The arguments passed to the function */
    args: Args;
    returned: Return;
    /** The original spied on function */
    original: Fn<Args, Return>;
}
type Fn<Args extends unknown[], R> = (...args: Args) => R;
type OverrideFn<Args extends unknown[], Return> = (callback: (info: OverrideInfo<Args, Return>) => Return) => BrowserSpy<any, any[]>;
export type BrowserSpy<Return, Args extends unknown[]> = Mock<Return, Args> & {
    override: OverrideFn<Args, Return>;
    overrideOnce: OverrideFn<Args, Return>;
} & Promise<Mock<Return, Args>>;
export declare const spied: <T extends Fn<unknown[], unknown>>(fn: T) => (T extends Fn<infer Args extends unknown[], infer Return> ? BrowserSpy<Return, Args> : never) & T;
type FunctionPropertyNames<T> = {
    [K in keyof T]: T[K] extends Function ? K : never;
}[keyof T];
declare function spyOnWrapped<T, K extends FunctionPropertyNames<T>>(obj: T, method: K): T[K] extends Fn<infer Args, infer Return> ? BrowserSpy<Return, Args> : BrowserSpy<any[], any>;
declare function spyOnWrapped<T>(obj: T, method: keyof T, accessType: 'get' | 'set'): BrowserSpy<any[], any>;
export declare const browserMock: {
    spyOn: typeof spyOnWrapped;
    fn: (impl?: ((...args: any) => any) | undefined) => BrowserSpy<any, any>;
};
export {};
//# sourceMappingURL=browser-mock.d.ts.map