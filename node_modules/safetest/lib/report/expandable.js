"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Expandable = void 0;
const react_1 = __importDefault(require("react"));
const usePrevious = (value) => {
    const ref = react_1.default.useRef(value);
    react_1.default.useEffect(() => {
        ref.current = value;
    });
    return ref.current;
};
const Expandable = ({ expanded, children, ms }) => {
    const actualMs = ms ?? 200;
    const ref = react_1.default.useRef(null);
    const [myExpanded, setMyExpanded] = react_1.default.useState(expanded);
    const timeoutRef = react_1.default.useRef();
    const previousExpanded = usePrevious(expanded);
    const changed = react_1.default.useRef(false);
    const initialHide = react_1.default.useRef(!expanded);
    const transition = (ms) => `all ${ms}ms ease-in-out`;
    const myExpand = react_1.default.useCallback((nextExpanded) => {
        const node = ref.current;
        if (node) {
            if (!changed.current) {
                node.style.transition = transition(actualMs);
            }
            if (nextExpanded === myExpanded)
                return;
            clearTimeout(timeoutRef.current);
            timeoutRef.current = undefined;
            setMyExpanded(nextExpanded);
            const getHeight = () => node.getBoundingClientRect().height;
            const start = getHeight();
            node.style.maxHeight = '';
            const full = getHeight();
            const end = nextExpanded ? full : 0;
            node.style.maxHeight = `${start}px`;
            node.getBoundingClientRect();
            const percentageOfFullAnimation = Math.abs(end - start) / full;
            const timeout = (actualMs ?? 2000) * percentageOfFullAnimation;
            node.style.transition = transition(timeout);
            node.style.maxHeight = `${end}px`;
            timeoutRef.current = setTimeout(() => {
                changed.current = true;
                timeoutRef.current = undefined;
                if (nextExpanded)
                    node.style.maxHeight = '';
            }, timeout);
        }
    }, [actualMs, myExpanded]);
    react_1.default.useEffect(() => {
        if (previousExpanded !== expanded)
            myExpand(expanded);
    }, [previousExpanded, expanded, myExpand]);
    const style = { overflow: 'hidden' };
    if (initialHide.current)
        style.maxHeight = '0';
    return react_1.default.createElement("div", { style: style, ref: ref, children: children });
};
exports.Expandable = Expandable;
