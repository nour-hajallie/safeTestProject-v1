{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.render = exports.SAFETEST_INTERFACE = void 0;\nconst deepmerge_1 = __importDefault(require(\"deepmerge\"));\nconst state_1 = require(\"./state\");\nconst is_in_node_1 = require(\"./is-in-node\");\nconst get_page_1 = require(\"./get-page\");\nconst safe_require_1 = require(\"./safe-require\");\nconst ensure_dir_1 = require(\"./ensure-dir\");\nconst make_pause_1 = require(\"./make-pause\");\nconst get_retry_attempt_1 = require(\"./get-retry-attempt\");\nconst anythingProxy_1 = require(\"./anythingProxy\");\nconst expose_function_1 = require(\"./expose-function\");\nconst defer_1 = require(\"./defer\");\nexports.SAFETEST_INTERFACE = '__safetestApi__';\nconst timeout = ms => new Promise(r => setTimeout(r, ms).unref?.());\nconst IGNORE_CONSOLE_MESSAGES = [/^\\[vite\\] connected\\.$/, /^\\[vite\\] connecting\\.\\.\\.$/, /^Download the Vue Devtools extension for a better development experience/, /^You are running Vue in development mode/, /^%cDownload the React DevTools for a better development experience/, /\\[HMR\\] Waiting for update signal from WDS\\.\\.\\.$/, /^\\[webpack-dev-server\\] Live Reloading enabled.$/, /^\\[webpack-dev-server\\] Server started/, /^Go to .* to debug this test$/, /^Download the Apollo DevTools/];\nconst backoffMs = [500, 750, 1000, 2000];\nasync function render(element, options, howToRender) {\n  if (state_1.state.options) {\n    options = (0, deepmerge_1.default)(state_1.state.options, options);\n  }\n  state_1.state.pauseAtEveryStep = !!options.debugTests;\n  if (typeof process !== 'undefined' && process.env['SAFETEST_OPTIONS']) {\n    options = (0, deepmerge_1.default)(options, JSON.parse(process.env['SAFETEST_OPTIONS']));\n  }\n  options.headless = state_1.state.debugging.has(state_1.state.activeTest ?? '') ? false : 'headless' in options ? options.headless : true;\n  let url = options.url ?? (typeof process !== 'undefined' ? process.env['BASE_URL'] : 'http://localhost:3000') ?? 'http://localhost:3000';\n  if (is_in_node_1.isInNode) {\n    if (options.subPath) {\n      url = `${new URL(options.subPath, options.url)}`;\n    }\n    const console = (0, safe_require_1.safeRequire)('console');\n    let page = state_1.state.browserContextInstance?.pages()[0];\n    const inspector = (0, safe_require_1.safeRequire)('inspector');\n    const path = (0, safe_require_1.safeRequire)('path');\n    const videoDir = options.recordVideo?.dir ?? options.videosPath;\n    const getFilePath = () => {\n      const filename = state_1.state.getState().testPath ?? '';\n      state_1.state.testPath = filename;\n      const bootstrapDir = path.dirname(state_1.state.bootstrappedAt);\n      const filenameWithoutExt = filename.split('.').slice(0, -1).join('.');\n      let relative = path.relative(bootstrapDir, filenameWithoutExt);\n      if (!relative.startsWith('.')) relative = `./${relative}`;\n      return relative;\n    };\n    const attempt = (0, get_retry_attempt_1.getRetryAttempt)();\n    const switchingHeadlessness = state_1.state.browserContextInstance && state_1.state.browserContextInstance.headless !== options.headless;\n    if (!page || videoDir || switchingHeadlessness) {\n      // If there is videoDir for this test, we need can't reuse an old browserContext that\n      // wasn't recording video.\n      ({\n        page\n      } = await (0, get_page_1.getPage)(options, !!videoDir || switchingHeadlessness));\n      if (!page._safetest_internal.safeTestExposed) {\n        page._safetest_internal.safeTestExposed = true;\n        await (0, expose_function_1.exposeFunction)(page, exports.SAFETEST_INTERFACE, async (type, ...args) => {\n          const safetest_internal = page._safetest_internal;\n          if (type === 'READY') {\n            return safetest_internal.renderIsReadyDeferred?.resolve();\n          }\n          if (type === 'GET_INFO') {\n            const info = {\n              testName: state_1.state.activeTest,\n              testPath: getFilePath(),\n              retryAttempt: attempt\n            };\n            const hooks = safetest_internal.hooks;\n            for (const beforeRender of hooks.beforeRender ?? []) {\n              await beforeRender(page, info);\n            }\n            return info;\n          }\n          if (type === 'BRIDGE') {\n            const [response] = args;\n            if ('result' in response) {\n              safetest_internal.pendingBridge.resolve(response.result);\n            } else {\n              safetest_internal.pendingBridge.reject(response.error);\n            }\n            return;\n          }\n          console.log('unhandled SAFETEST_INTERFACE call', JSON.stringify({\n            type,\n            args\n          }));\n          return;\n        });\n      }\n    }\n    page._safetest_internal = (0, deepmerge_1.default)(page._safetest_internal, {\n      // coveragePath: options.coverageDir,\n      videoDir,\n      failureScreenshotDir: options.failureScreenshotsDir\n    });\n    if (options.recordTraces) {\n      await page.context().tracing.start({\n        screenshots: true,\n        snapshots: true,\n        sources: true,\n        title: state_1.state.activeTest\n      });\n      const test = expect.getState().currentTestName ?? '<unknown>';\n      const testPath = path.relative(process.cwd(), expect.getState().testPath).replace(/[^a-z0-9_]/g, '_');\n      const activeTest = state_1.state.activeTest;\n      page._safetest_internal.hooks.afterTest.push(async () => {\n        const safeName = activeTest?.replace(/[^a-z0-9_]/gi, '_');\n        const path = `${options.recordTraces}/traces/${testPath}_${safeName}-attempt-${attempt}.zip`;\n        state_1.state.artifacts.push({\n          type: 'trace',\n          test,\n          path,\n          confirmed: true\n        });\n        try {\n          await page.context().tracing.stop({\n            path\n          });\n        } catch {}\n      });\n    }\n    const isDebugging = state_1.state.debugging.has(state_1.state.activeTest ?? '');\n    state_1.state.exposeGlobals['page'] = page;\n    const pause = state_1.state.pause = await (0, make_pause_1.makePause)({\n      page,\n      isDebugging\n    });\n    for (const beforeNavigate of page._safetest_internal.hooks.beforeNavigate) {\n      await beforeNavigate(page);\n    }\n    const oldPagePause = page.pause;\n    page.pause = async () => {\n      const url = inspector.url();\n      let port = 0;\n      if (url) {\n        port = +new URL(url).port;\n      }\n      if (port) inspector.close();\n      await oldPagePause.call(page);\n      if (port) {\n        inspector.open(port);\n        inspector.waitForDebugger();\n      }\n    };\n    const consoleMessagesGroups = {};\n    page.on('console', async msg => {\n      const text = msg.text();\n      for (const ignore of [...IGNORE_CONSOLE_MESSAGES, ...(options.ignoreConsoleMessages ?? [])]) {\n        if (ignore.test(text)) {\n          return;\n        }\n      }\n      try {\n        const args = (await Promise.all(msg.args().map(a => a.jsonValue()))).map(a => JSON.stringify(a));\n        const params = [`${msg.type()}:`];\n        if (args.length) params.push(...args);else params.push(text);\n        const key = JSON.stringify(params);\n        if (!consoleMessagesGroups[key]) consoleMessagesGroups[key] = 0;\n        consoleMessagesGroups[key]++;\n      } catch {\n        const params = [`${msg.type()}:`, text];\n        const key = JSON.stringify(params);\n        if (!consoleMessagesGroups[key]) consoleMessagesGroups[key] = 0;\n        consoleMessagesGroups[key]++;\n      }\n    });\n    page._safetest_internal.hooks.afterTest.push(async () => {\n      const consoleLines = [];\n      const entries = Object.entries(consoleMessagesGroups);\n      consoleLines.push('Console messages: ');\n      for (const [key, count] of entries) {\n        const args = JSON.parse(key).join(' ');\n        consoleLines.push((count > 1 ? `(${count}X) ` : '') + `${args}`);\n      }\n      if (entries.length) {\n        console.log(consoleLines.map((l, i) => i ? `  ${l}` : l).join('\\n'));\n      }\n    });\n    page._safetest_internal.hooks.afterTest.push(async () => {\n      const errors = [];\n      for (const [key, value] of Object.entries(state_1.state.pendingExpects)) {\n        if (value) errors.push(new Error(`Expected ${value} ${key}() calls to be awaited, but they were not.`));\n      }\n      state_1.state.pendingExpects = {};\n      if (errors.length) {\n        throw new Error(errors.map(e => e.message).join('\\n'));\n      }\n    });\n    const failDir = page._safetest_internal.failureScreenshotDir;\n    if (failDir) {\n      const activeTest = state_1.state.activeTest;\n      page._safetest_internal.hooks.afterTest.push(async () => {\n        const passed = state_1.state.passedTests.has(activeTest ?? '');\n        if (!passed) {\n          const pages = state_1.state.browserContextInstance?.pages();\n          for (const [index, page] of pages?.entries() ?? []) {\n            const suffix = index ? `_${index}` : '';\n            const path = `${failDir}/${activeTest}${suffix}.png`;\n            await page.screenshot({\n              path\n            });\n          }\n        }\n      });\n    }\n    if (videoDir) {\n      const test = expect.getState().currentTestName ?? '<unknown>';\n      const testPath = path.relative(process.cwd(), expect.getState().testPath).replace(/[^a-z0-9_]/g, '_');\n      const activeTest = state_1.state.activeTest;\n      page._safetest_internal.hooks.afterTest.push(async () => {\n        const pages = state_1.state.browserContextInstance?.pages();\n        for (const page of pages ?? []) {\n          const index = page._safetest_internal.pageIndex;\n          await (0, ensure_dir_1.ensureDir)(videoDir);\n          const suffix = (pages?.length ?? 0) > 1 ? `_tab${index}` : '';\n          const safeName = activeTest?.replace(/[^a-z0-9_]/gi, '_');\n          const newName = `${safeName}-attempt-${attempt}${suffix}.webm`;\n          const path = `${videoDir}/${testPath}_${newName}`;\n          state_1.state.artifacts.push({\n            type: 'video',\n            test,\n            path,\n            confirmed: true\n          });\n          page?.video()?.saveAs(path);\n        }\n      });\n    }\n    // Workaround issue where Playwright sometimes doesn't goto the url after a call to page.goto()\n    const gotoAttempts = 5;\n    let attemptsLeft = gotoAttempts;\n    class PageReadyTimeoutError extends Error {\n      constructor() {\n        super(...arguments);\n        this.name = 'PageReadyTimeoutError';\n      }\n    }\n    const gotoTestUrl = async () => {\n      const defer = (0, defer_1.deferred)();\n      const rejectForTimeout = () => defer.reject(new PageReadyTimeoutError());\n      const getUrl = () => {\n        return page.evaluate(() => location.href).catch(() => page.url());\n      };\n      const attempt = gotoAttempts - attemptsLeft;\n      const initialNavigationTimeout = options.initialNavigationTimeout ?? options.defaultNavigationTimeout ?? backoffMs[attempt] ?? 5000;\n      setTimeout(async () => {\n        if (gotoAttempts - attemptsLeft !== attempt) return;\n        // Sometimes the page.goto doesn't register, this will detect that.\n        const halted = new URL(await getUrl()).origin !== new URL(url).origin;\n        if (halted) return rejectForTimeout();\n        // The page has no pending network requests and didn't resolve `renderIsReadyDeferred`.\n        page.waitForLoadState('networkidle').then(rejectForTimeout, () => {});\n      }, initialNavigationTimeout);\n      page.goto(url, {\n        waitUntil: 'commit',\n        timeout: initialNavigationTimeout\n      }).catch(async error => {\n        const halted = new URL(await getUrl()).origin !== new URL(url).origin;\n        if (halted) defer.reject(error);\n      }).then(() => page._safetest_internal.renderIsReadyDeferred?.promise).then(() => defer.resolve());\n      return defer.promise.catch(error => {\n        const shouldRetry = attemptsLeft-- > 0;\n        const plan = shouldRetry ? `retrying (attempts left: ${attemptsLeft + 1})...` : 'giving up';\n        console.log(`page.goto error: ${error.name} on \"${state_1.state.activeTest}\" ${plan}`);\n        if (shouldRetry) return gotoTestUrl();\n        throw new PageReadyTimeoutError();\n      });\n    };\n    const testName = state_1.state.activeTest;\n    page._safetest_internal.renderIsReadyDeferred = (0, defer_1.deferred)();\n    await gotoTestUrl();\n    const debugUrl = await page.evaluate(({\n      testName,\n      testPath\n    }) => {\n      const url = new URL(window.location.href);\n      url.searchParams.set('test_name', testName);\n      url.searchParams.set('test_path', testPath);\n      const debugUrl = url.toString().replace(/%2F/g, '/');\n      console.log(`Go to ${debugUrl} to debug this test`);\n      return debugUrl;\n    }, {\n      testName: state_1.state.activeTest,\n      testPath: getFilePath()\n    });\n    if (isDebugging) {\n      console.log(`Go to ${debugUrl} to debug this test`);\n    }\n    page._safetest_internal.hooks.afterTest.push(async () => {\n      const activeTest = testName ?? '';\n      timeout(100).then(() => {\n        const passed = state_1.state.passedTests.has(activeTest);\n        if (!passed && !isDebugging) {\n          console.log(`'${state_1.state.activeTest}' Failed. Go to ${debugUrl.replace('host.docker.internal', 'localhost')} to debug this test`);\n        }\n      });\n    });\n    const bridge = state_1.state.bridge = async passed => {\n      if (typeof passed === 'function') passed = {};\n      page._safetest_internal.pendingBridge = (0, defer_1.deferred)();\n      await page.evaluate(({\n        passed,\n        SAFETEST_INTERFACE\n      }) => {\n        const {\n          callback,\n          defer\n        } = window[SAFETEST_INTERFACE].bridgePending;\n        Promise.resolve().then(() => callback(passed)).then(result => {\n          window[SAFETEST_INTERFACE]('BRIDGE', {\n            result\n          });\n          defer.resolve(result);\n        }).catch(error => {\n          window[SAFETEST_INTERFACE]('BRIDGE', {\n            error\n          })(window).safeTestBridge({\n            error\n          });\n          defer.reject(error);\n        });\n      }, {\n        passed,\n        SAFETEST_INTERFACE: exports.SAFETEST_INTERFACE\n      });\n      return await page._safetest_internal.pendingBridge?.promise;\n    };\n    const rendered = {\n      page,\n      pause,\n      bridge,\n      require: safe_require_1.safeRequire\n    };\n    return rendered;\n  } else {\n    if (!state_1.state.browserState) {\n      throw new Error('App was not bootstrapped to use safetest correctly');\n    }\n    if (options.subPath) {\n      try {\n        const dummyUrl = new URL(options.subPath, 'http://localhost:3000');\n        const pathname = dummyUrl.pathname;\n        const dummyUrl2 = new URL(options.subPath, dummyUrl);\n        const different = pathname !== dummyUrl2.pathname;\n        // subPath is something like `foo/` and every page reload we'll end up adding another `foo/` to the url incorrectly.\n        // This is detects and breaks out of that loop.\n        const skip = different && location.pathname.includes(pathname);\n        if (!skip) {\n          const url = new URL(options.subPath, location.href);\n          const search = new URLSearchParams([...url.searchParams, ...[...new URLSearchParams(location.search)]]).toString();\n          url.search = search;\n          url.hash = location.hash;\n          history.pushState(null, '', `${url}`);\n        }\n      } catch {}\n    }\n    await howToRender(element);\n    const bridge = state_1.state.bridge = (passed, callback) => {\n      if (!callback) callback = passed;\n      const defer = (0, defer_1.deferred)();\n      if (!window[exports.SAFETEST_INTERFACE]) {\n        console.log('Test is waiting for a bridge call, you can manually invoke it with: `bridged(...)`. Waiting by:', callback);\n        window.bridged = passed => {\n          delete window.bridged;\n          defer.resolve(passed);\n          return callback(passed);\n        };\n      } else {\n        window[exports.SAFETEST_INTERFACE].bridgePending = {\n          callback,\n          defer\n        };\n      }\n      return defer.promise;\n    };\n    if (typeof window[exports.SAFETEST_INTERFACE] === 'function') {\n      window[exports.SAFETEST_INTERFACE]?.('READY');\n    }\n    // await timeout(0);\n    return {\n      page: anythingProxy_1.anythingProxy,\n      pause: () => Promise.resolve(),\n      bridge,\n      require: anythingProxy_1.anythingProxy\n    };\n  }\n}\nexports.render = render;","map":{"version":3,"names":["deepmerge_1","__importDefault","require","state_1","is_in_node_1","get_page_1","safe_require_1","ensure_dir_1","make_pause_1","get_retry_attempt_1","anythingProxy_1","expose_function_1","defer_1","exports","SAFETEST_INTERFACE","timeout","ms","Promise","r","setTimeout","unref","IGNORE_CONSOLE_MESSAGES","backoffMs","render","element","options","howToRender","state","default","pauseAtEveryStep","debugTests","process","env","JSON","parse","headless","debugging","has","activeTest","url","isInNode","subPath","URL","console","safeRequire","page","browserContextInstance","pages","inspector","path","videoDir","recordVideo","dir","videosPath","getFilePath","filename","getState","testPath","bootstrapDir","dirname","bootstrappedAt","filenameWithoutExt","split","slice","join","relative","startsWith","attempt","getRetryAttempt","switchingHeadlessness","getPage","_safetest_internal","safeTestExposed","exposeFunction","type","args","safetest_internal","renderIsReadyDeferred","resolve","info","testName","retryAttempt","hooks","beforeRender","response","pendingBridge","result","reject","error","log","stringify","failureScreenshotDir","failureScreenshotsDir","recordTraces","context","tracing","start","screenshots","snapshots","sources","title","test","expect","currentTestName","cwd","replace","afterTest","push","safeName","artifacts","confirmed","stop","isDebugging","exposeGlobals","pause","makePause","beforeNavigate","oldPagePause","port","close","call","open","waitForDebugger","consoleMessagesGroups","on","msg","text","ignore","ignoreConsoleMessages","all","map","a","jsonValue","params","length","key","consoleLines","entries","Object","count","l","i","errors","value","pendingExpects","Error","e","message","failDir","passed","passedTests","index","suffix","screenshot","pageIndex","ensureDir","newName","video","saveAs","gotoAttempts","attemptsLeft","PageReadyTimeoutError","constructor","name","gotoTestUrl","defer","deferred","rejectForTimeout","getUrl","evaluate","location","href","catch","initialNavigationTimeout","defaultNavigationTimeout","halted","origin","waitForLoadState","then","goto","waitUntil","promise","shouldRetry","plan","debugUrl","window","searchParams","set","toString","bridge","callback","bridgePending","safeTestBridge","rendered","browserState","dummyUrl","pathname","dummyUrl2","different","skip","includes","search","URLSearchParams","hash","history","pushState","bridged","anythingProxy"],"sources":["/Users/nour/Documents/GitHub/safeTestProject-v1/node_modules/safetest/src/render.ts"],"sourcesContent":["import type { Page, BrowserContextOptions, LaunchOptions } from 'playwright';\n\nimport merge from 'deepmerge';\n\nimport { state } from './state';\nimport { isInNode } from './is-in-node';\nimport { getPage } from './get-page';\nimport { SafeRequire, safeRequire } from './safe-require';\nimport { ensureDir } from './ensure-dir';\nimport { Hooks, SafePage } from './safepage';\nimport { makePause } from './make-pause';\nimport { getRetryAttempt } from './get-retry-attempt';\nimport { anythingProxy } from './anythingProxy';\nimport type { MatchImageSnapshotOptions } from 'jest-image-snapshot';\nimport { exposeFunction } from './expose-function';\nimport { deferred } from './defer';\n\nexport const SAFETEST_INTERFACE = '__safetestApi__';\n\nconst timeout = (ms: number) => new Promise((r) => setTimeout(r, ms).unref?.());\n\nexport interface Bridge {\n  <Return>(callback: () => Return | Promise<Return>): Promise<Return>;\n  <Args, Return>(\n    args: Args,\n    callback: (args: Args) => Return | Promise<Return>\n  ): Promise<Return>;\n}\n\nexport interface RenderOptions extends LaunchOptions, BrowserContextOptions {\n  browser?: 'chromium' | 'firefox' | 'webkit';\n  /** The base URL of the running app. Defaults to `localhost:3000` per CRA. */\n  url?: string;\n  /** Remote server to connect to. See https://playwright.dev/docs/api/class-browsertype#browser-type-launch-server */\n  browserServer?: string;\n  /** The subpath to navigate to when opening the page. */\n  subPath?: string;\n  /** options to use in CI. */\n  ciOptions?:\n    | {\n        /**\n         * Shorthand for:\n         *\n         *     failureScreenshotsDir: `${ARTIFACTS_DIR}/failure_screenshots`,\n         *     recordVideo: { dir: `${ARTIFACTS_DIR}/videos` },\n         *     recordTraces: `${ARTIFACTS_DIR}/traces`,\n         *     matchImageSnapshotOptions: {\n         *       customDiffDir: `${ARTIFACTS_DIR}/image_diffs`,\n         *       storeReceivedOnFailure: true,\n         *       customReceivedDir: `${ARTIFACTS_DIR}/updated_snapshots`,\n         *       customReceivedPostfix: '',\n         *       failureThreshold: 0,\n         *     }\n         */\n        usingArtifactsDir: string;\n      }\n    | RenderOptions;\n  /** Path to record coverage json files to for each test */\n  // coverageDir?: string;\n  /** Path to failure-screenshots, defaults to `failure-screenshots/`. */\n  failureScreenshotsDir?: string;\n  hooks?: Partial<Hooks>;\n  recordTraces?: string;\n  ignoreConsoleMessages?: RegExp[];\n  /** The default timeout. See {@link Page.setDefaultTimeout} */\n  defaultTimeout?: number;\n  /** The timeout for the first page render in case there are some network auth handshakes that take a while. */\n  initialNavigationTimeout?: number;\n  /** The default timeout for navigation. See {@link Page.setDefaultNavigationTimeout} */\n  defaultNavigationTimeout?: number;\n  matchImageSnapshotOptions?: MatchImageSnapshotOptions;\n  /** Run the tests inside a docker container for consistency. */\n  useDocker?: boolean;\n  /** HACK: enable workaround to allow screen casting the page without breaking playwright events. */\n  enableScreenCasting?: boolean;\n  /** Only run test the following tests (full test name). */\n  debugTests?: string[];\n}\n\nexport interface RenderReturn {\n  /** The Playwright page object of the rendered component. */\n  page: Page;\n  /** Pause current test. */\n  pause: () => Promise<void>;\n  /** Bridge API to communicate with browser from node */\n  bridge: Bridge;\n  /** Node require function, will return an `anything` proxy in the browser */\n  require: SafeRequire;\n}\n\ntype RenderableThing = { __isRenderable: true; thing: any };\n\nconst IGNORE_CONSOLE_MESSAGES = [\n  /^\\[vite\\] connected\\.$/,\n  /^\\[vite\\] connecting\\.\\.\\.$/,\n  /^Download the Vue Devtools extension for a better development experience/,\n  /^You are running Vue in development mode/,\n  /^%cDownload the React DevTools for a better development experience/,\n  /\\[HMR\\] Waiting for update signal from WDS\\.\\.\\.$/,\n  /^\\[webpack-dev-server\\] Live Reloading enabled.$/,\n  /^\\[webpack-dev-server\\] Server started/,\n  /^Go to .* to debug this test$/,\n  /^Download the Apollo DevTools/,\n];\n\nconst backoffMs = [500, 750, 1000, 2000] as const;\n\nexport async function render(\n  element: RenderableThing,\n  options: RenderOptions,\n  howToRender: (element: RenderableThing) => Promise<any>\n): Promise<RenderReturn> {\n  if (state.options) {\n    options = merge(state.options, options);\n  }\n  state.pauseAtEveryStep = !!options.debugTests;\n\n  if (typeof process !== 'undefined' && process.env['SAFETEST_OPTIONS']) {\n    options = merge(\n      options,\n      JSON.parse(process.env['SAFETEST_OPTIONS']) as RenderOptions\n    );\n  }\n  options.headless = state.debugging.has(state.activeTest ?? '')\n    ? false\n    : 'headless' in options\n    ? options.headless\n    : true;\n  let url =\n    options.url ??\n    (typeof process !== 'undefined'\n      ? process.env['BASE_URL']\n      : 'http://localhost:3000') ??\n    'http://localhost:3000';\n\n  if (isInNode) {\n    if (options.subPath) {\n      url = `${new URL(options.subPath, options.url)}`;\n    }\n    const console = safeRequire('console');\n    let page = state.browserContextInstance?.pages()[0] as SafePage;\n\n    const inspector = safeRequire('inspector');\n    const path = safeRequire('path');\n\n    const videoDir = options.recordVideo?.dir ?? options.videosPath;\n\n    const getFilePath = () => {\n      const filename = state.getState().testPath ?? '';\n      state.testPath = filename;\n\n      const bootstrapDir = path.dirname(state.bootstrappedAt);\n      const filenameWithoutExt = filename.split('.').slice(0, -1).join('.');\n      let relative = path.relative(bootstrapDir, filenameWithoutExt);\n      if (!relative.startsWith('.')) relative = `./${relative}`;\n      return relative;\n    };\n\n    const attempt = getRetryAttempt();\n\n    const switchingHeadlessness =\n      state.browserContextInstance &&\n      state.browserContextInstance.headless !== options.headless;\n    if (!page || videoDir || switchingHeadlessness) {\n      // If there is videoDir for this test, we need can't reuse an old browserContext that\n      // wasn't recording video.\n      ({ page } = await getPage(options, !!videoDir || switchingHeadlessness));\n\n      if (!page._safetest_internal.safeTestExposed) {\n        page._safetest_internal.safeTestExposed = true;\n        await exposeFunction(\n          page,\n          SAFETEST_INTERFACE,\n          async (type: string, ...args: any[]) => {\n            const safetest_internal = page._safetest_internal;\n            if (type === 'READY') {\n              return safetest_internal.renderIsReadyDeferred?.resolve();\n            }\n            if (type === 'GET_INFO') {\n              const info = {\n                testName: state.activeTest,\n                testPath: getFilePath(),\n                retryAttempt: attempt,\n              };\n              const hooks = safetest_internal.hooks;\n              for (const beforeRender of hooks.beforeRender ?? []) {\n                await beforeRender(page, info);\n              }\n              return info;\n            }\n            if (type === 'BRIDGE') {\n              const [response] = args;\n              if ('result' in response) {\n                safetest_internal.pendingBridge.resolve(response.result);\n              } else {\n                safetest_internal.pendingBridge.reject(response.error);\n              }\n              return;\n            }\n            console.log(\n              'unhandled SAFETEST_INTERFACE call',\n              JSON.stringify({ type, args })\n            );\n            return;\n          }\n        );\n      }\n    }\n\n    page._safetest_internal = merge(page._safetest_internal, {\n      // coveragePath: options.coverageDir,\n      videoDir,\n      failureScreenshotDir: options.failureScreenshotsDir,\n    } as Partial<SafePage['_safetest_internal']>);\n\n    if (options.recordTraces) {\n      await page.context().tracing.start({\n        screenshots: true,\n        snapshots: true,\n        sources: true,\n        title: state.activeTest!,\n      });\n      const test = expect.getState().currentTestName ?? '<unknown>';\n      const testPath = path\n        .relative(process.cwd(), expect.getState().testPath!)\n        .replace(/[^a-z0-9_]/g, '_');\n      const activeTest = state.activeTest;\n      page._safetest_internal.hooks.afterTest.push(async () => {\n        const safeName = activeTest?.replace(/[^a-z0-9_]/gi, '_');\n        const path = `${options.recordTraces}/traces/${testPath}_${safeName}-attempt-${attempt}.zip`;\n        state.artifacts.push({ type: 'trace', test, path, confirmed: true });\n        try {\n          await page.context().tracing.stop({ path });\n        } catch {}\n      });\n    }\n\n    const isDebugging = state.debugging.has(state.activeTest ?? '');\n\n    state.exposeGlobals['page'] = page;\n    const pause = (state.pause = await makePause({ page, isDebugging }));\n\n    for (const beforeNavigate of page._safetest_internal.hooks.beforeNavigate) {\n      await beforeNavigate(page);\n    }\n\n    const oldPagePause = page.pause;\n    page.pause = (async () => {\n      const url = inspector.url();\n      let port = 0;\n      if (url) {\n        port = +new URL(url).port;\n      }\n      if (port) inspector.close();\n      await oldPagePause.call(page);\n      if (port) {\n        inspector.open(port);\n        inspector.waitForDebugger();\n      }\n    }) as any;\n\n    const consoleMessagesGroups: Record<string, number> = {};\n    page.on('console', async (msg) => {\n      const text = msg.text();\n      for (const ignore of [\n        ...IGNORE_CONSOLE_MESSAGES,\n        ...(options.ignoreConsoleMessages ?? []),\n      ]) {\n        if (ignore.test(text)) {\n          return;\n        }\n      }\n\n      try {\n        const args = (\n          await Promise.all(msg.args().map((a) => a.jsonValue()))\n        ).map((a) => JSON.stringify(a));\n        const params = [`${msg.type()}:`];\n        if (args.length) params.push(...args);\n        else params.push(text);\n        const key = JSON.stringify(params);\n        if (!consoleMessagesGroups[key]) consoleMessagesGroups[key] = 0;\n        consoleMessagesGroups[key]++;\n      } catch {\n        const params = [`${msg.type()}:`, text];\n        const key = JSON.stringify(params);\n        if (!consoleMessagesGroups[key]) consoleMessagesGroups[key] = 0;\n        consoleMessagesGroups[key]++;\n      }\n    });\n\n    page._safetest_internal.hooks.afterTest.push(async () => {\n      const consoleLines: string[] = [];\n      const entries = Object.entries(consoleMessagesGroups);\n      consoleLines.push('Console messages: ');\n      for (const [key, count] of entries) {\n        const args = JSON.parse(key).join(' ');\n        consoleLines.push((count > 1 ? `(${count}X) ` : '') + `${args}`);\n      }\n      if (entries.length) {\n        console.log(consoleLines.map((l, i) => (i ? `  ${l}` : l)).join('\\n'));\n      }\n    });\n\n    page._safetest_internal.hooks.afterTest.push(async () => {\n      const errors: Error[] = [];\n      for (const [key, value] of Object.entries(state.pendingExpects)) {\n        if (value)\n          errors.push(\n            new Error(\n              `Expected ${value} ${key}() calls to be awaited, but they were not.`\n            )\n          );\n      }\n      state.pendingExpects = {};\n      if (errors.length) {\n        throw new Error(errors.map((e) => e.message).join('\\n'));\n      }\n    });\n\n    const failDir = page._safetest_internal.failureScreenshotDir;\n    if (failDir) {\n      const activeTest = state.activeTest;\n      page._safetest_internal.hooks.afterTest.push(async () => {\n        const passed = state.passedTests.has(activeTest ?? '');\n        if (!passed) {\n          const pages = state.browserContextInstance?.pages();\n          for (const [index, page] of pages?.entries() ?? []) {\n            const suffix = index ? `_${index}` : '';\n            const path = `${failDir}/${activeTest}${suffix}.png`;\n            await page.screenshot({ path });\n          }\n        }\n      });\n    }\n\n    if (videoDir) {\n      const test = expect.getState().currentTestName ?? '<unknown>';\n      const testPath = path\n        .relative(process.cwd(), expect.getState().testPath!)\n        .replace(/[^a-z0-9_]/g, '_');\n      const activeTest = state.activeTest;\n      page._safetest_internal.hooks.afterTest.push(async () => {\n        const pages = state.browserContextInstance?.pages() as SafePage[];\n        for (const page of pages ?? []) {\n          const index = page._safetest_internal.pageIndex;\n          await ensureDir(videoDir);\n\n          const suffix = (pages?.length ?? 0) > 1 ? `_tab${index}` : '';\n          const safeName = activeTest?.replace(/[^a-z0-9_]/gi, '_');\n          const newName = `${safeName}-attempt-${attempt}${suffix}.webm`;\n          const path = `${videoDir}/${testPath}_${newName}`;\n          state.artifacts.push({ type: 'video', test, path, confirmed: true });\n          page?.video()?.saveAs(path);\n        }\n      });\n    }\n\n    // Workaround issue where Playwright sometimes doesn't goto the url after a call to page.goto()\n    const gotoAttempts = 5;\n    let attemptsLeft = gotoAttempts;\n    class PageReadyTimeoutError extends Error {\n      override name = 'PageReadyTimeoutError';\n    }\n\n    const gotoTestUrl: () => Promise<void> = async () => {\n      const defer = deferred();\n      const rejectForTimeout = () => defer.reject(new PageReadyTimeoutError());\n\n      const getUrl = () => {\n        return page.evaluate(() => location.href).catch(() => page.url());\n      };\n      const attempt = gotoAttempts - attemptsLeft;\n      const initialNavigationTimeout =\n        options.initialNavigationTimeout ??\n        options.defaultNavigationTimeout ??\n        backoffMs[attempt] ??\n        5000;\n\n      setTimeout(async () => {\n        if (gotoAttempts - attemptsLeft !== attempt) return;\n        // Sometimes the page.goto doesn't register, this will detect that.\n        const halted = new URL(await getUrl()).origin !== new URL(url).origin;\n        if (halted) return rejectForTimeout();\n\n        // The page has no pending network requests and didn't resolve `renderIsReadyDeferred`.\n        page.waitForLoadState('networkidle').then(rejectForTimeout, () => {});\n      }, initialNavigationTimeout);\n\n      page\n        .goto(url, { waitUntil: 'commit', timeout: initialNavigationTimeout })\n        .catch(async (error) => {\n          const halted = new URL(await getUrl()).origin !== new URL(url).origin;\n\n          if (halted) defer.reject(error);\n        })\n        .then(() => page._safetest_internal.renderIsReadyDeferred?.promise)\n        .then(() => defer.resolve());\n\n      return defer.promise.catch((error) => {\n        const shouldRetry = attemptsLeft-- > 0;\n        const plan = shouldRetry\n          ? `retrying (attempts left: ${attemptsLeft + 1})...`\n          : 'giving up';\n        console.log(\n          `page.goto error: ${error.name} on \"${state.activeTest}\" ${plan}`\n        );\n        if (shouldRetry) return gotoTestUrl();\n        throw new PageReadyTimeoutError();\n      });\n    };\n\n    const testName = state.activeTest;\n    page._safetest_internal.renderIsReadyDeferred = deferred();\n    await gotoTestUrl();\n\n    const debugUrl = await page.evaluate(\n      ({ testName, testPath }) => {\n        const url = new URL(window.location.href);\n        url.searchParams.set('test_name', testName!);\n        url.searchParams.set('test_path', testPath!);\n        const debugUrl = url.toString().replace(/%2F/g, '/');\n        console.log(`Go to ${debugUrl} to debug this test`);\n        return debugUrl;\n      },\n      { testName: state.activeTest, testPath: getFilePath() }\n    );\n\n    if (isDebugging) {\n      console.log(`Go to ${debugUrl} to debug this test`);\n    }\n    page._safetest_internal.hooks.afterTest.push(async () => {\n      const activeTest = testName ?? '';\n      timeout(100).then(() => {\n        const passed = state.passedTests.has(activeTest);\n        if (!passed && !isDebugging) {\n          console.log(\n            `'${state.activeTest}' Failed. Go to ${debugUrl.replace(\n              'host.docker.internal',\n              'localhost'\n            )} to debug this test`\n          );\n        }\n      });\n    });\n\n    const bridge = (state.bridge = async (passed: any) => {\n      if (typeof passed === 'function') passed = {};\n      page._safetest_internal.pendingBridge = deferred();\n\n      await page.evaluate(\n        ({ passed, SAFETEST_INTERFACE }) => {\n          const { callback, defer } = (window as any)[SAFETEST_INTERFACE]\n            .bridgePending;\n          Promise.resolve()\n            .then(() => callback(passed))\n            .then((result: any) => {\n              (window as any)[SAFETEST_INTERFACE]('BRIDGE', { result });\n              defer.resolve(result);\n            })\n            .catch((error) => {\n              (window as any)\n                [SAFETEST_INTERFACE]('BRIDGE', { error })(window as any)\n                .safeTestBridge({ error });\n              defer.reject(error);\n            });\n        },\n        { passed, SAFETEST_INTERFACE }\n      );\n      return await page._safetest_internal.pendingBridge?.promise;\n    });\n\n    const rendered = {\n      page,\n      pause,\n      bridge,\n      require: safeRequire,\n    };\n\n    return rendered;\n  } else {\n    if (!state.browserState) {\n      throw new Error('App was not bootstrapped to use safetest correctly');\n    }\n    if (options.subPath) {\n      try {\n        const dummyUrl = new URL(options.subPath, 'http://localhost:3000');\n        const pathname = dummyUrl.pathname;\n        const dummyUrl2 = new URL(options.subPath, dummyUrl);\n        const different = pathname !== dummyUrl2.pathname;\n\n        // subPath is something like `foo/` and every page reload we'll end up adding another `foo/` to the url incorrectly.\n        // This is detects and breaks out of that loop.\n        const skip = different && location.pathname.includes(pathname);\n\n        if (!skip) {\n          const url = new URL(options.subPath, location.href);\n          const search = new URLSearchParams([\n            ...url.searchParams,\n            ...[...new URLSearchParams(location.search)],\n          ]).toString();\n          url.search = search;\n          url.hash = location.hash;\n          history.pushState(null, '', `${url}`);\n        }\n      } catch {}\n    }\n    await howToRender(element);\n\n    const bridge: any = (state.bridge = (passed: any, callback: any) => {\n      if (!callback) callback = passed;\n      const defer = deferred();\n      if (!(window as any)[SAFETEST_INTERFACE]) {\n        console.log(\n          'Test is waiting for a bridge call, you can manually invoke it with: `bridged(...)`. Waiting by:',\n          callback\n        );\n        (window as any).bridged = (passed: any) => {\n          delete (window as any).bridged;\n          defer.resolve(passed);\n          return callback(passed);\n        };\n      } else {\n        (window as any)[SAFETEST_INTERFACE].bridgePending = { callback, defer };\n      }\n\n      return defer.promise;\n    });\n\n    if (typeof (window as any)[SAFETEST_INTERFACE] === 'function') {\n      (window as any)[SAFETEST_INTERFACE]?.('READY');\n    }\n\n    // await timeout(0);\n\n    return {\n      page: anythingProxy,\n      pause: () => Promise.resolve(),\n      bridge,\n      require: anythingProxy,\n    };\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}